<!doctype html>
<html class="theme-next use-motion theme-next-mist">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />








  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>




<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.5.1"/>


    <meta name="description" content="Zhange's notes" />



  <meta name="keywords" content="NIO,java," />





  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.1" />


<meta name="description" content="java中的NIO。">
<meta property="og:type" content="article">
<meta property="og:title" content="Simple Java: NIO">
<meta property="og:url" content="http://yoursite.com/2015/09/29/Simple-Java-NIO/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="java中的NIO。">
<meta property="og:image" content="http://7xiwca.com1.z0.glb.clouddn.com/NIOwithIO.png">
<meta property="og:updated_time" content="2015-09-29T10:36:12.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Simple Java: NIO">
<meta name="twitter:description" content="java中的NIO。">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: 'Mist',
    sidebar: 'post'
  };
</script>

  <title> Simple Java: NIO | Hexo </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  



  <div class="container one-column page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand" rel="start">
      <span class="logo">
        <i class="icon-next-logo"></i>
      </span>
      <span class="site-title">Zhange's notes</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon icon-next-home"></i> <br />
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            <i class="menu-item-icon icon-next-archives"></i> <br />
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            <i class="menu-item-icon icon-next-tags"></i> <br />
            标签
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content"> 

  <div id="posts" class="posts-expand">
    

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              Simple Java: NIO
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-09-29T17:33:35+08:00" content="2015-09-29">
            2015-09-29
          </time>
        </span>

        

        
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        <span itemprop="articleBody"><h2 id="简介">简介</h2><p>Java NIO提供了与标准IO不同的IO工作方式： </p>
<ul>
<li>Channels and Buffers（通道和缓冲区）：标准的IO基于字节流和字符流进行操作的，而NIO是基于通道（Channel）和缓冲区（Buffer）进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。</li>
<li>Asynchronous IO（异步IO）：Java NIO可以让你异步的使用IO，例如：当线程从通道读取数据到缓冲区时，线程还是可以进行其他事情。当数据被写入到缓冲区时，线程可以继续处理它。从缓冲区写入通道也类似。</li>
<li>Selectors（选择器）：Java NIO引入了选择器的概念，选择器用于监听多个通道的事件（比如：连接打开，数据到达）。因此，单个的线程可以监听多个数据通道。</li>
</ul>
<h2 id="NIO核心">NIO核心</h2><ul>
<li>Channels</li>
<li>Buffers</li>
<li>Selectors</li>
</ul>
<p>所有的IO在NIO中都是从一个Channel开始，channel有点像是流，数据可以从channel读到buffer中，也可以冲buffer写到channel中。<br>channel和buffer有很多种实现。</p>
<p>一些主要的channel实现，这些通道涵盖了文件、UDP、TCP：</p>
<ul>
<li>FileChannel</li>
<li>DatagramChannel</li>
<li>SocketChannel</li>
<li>ServerSocketChannel</li>
</ul>
<p>一些主要的Buffer实现：</p>
<ul>
<li>ByteBuffer</li>
<li>CharBuffer</li>
<li>DoubleBuffer</li>
<li>FloatBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>ShortBuffer</li>
</ul>
<p>另外有Mappedyteuffer用于表示内存映射文件。</p>
<p>Selector允许单线程处理多个Channel。如果一个应用打开了多个连接（Channel），每个连接的流量又很低，Selector就会很合适。<br>要使用Selector，需要向Selector中注册Channel，然后调用他的select()方法。这个方法会一直阻塞到某个注册的channel有事件就绪。<br>一旦这个方法返回，线程就可以处理这些事件，比如新建连接、接收数据等。</p>
<h2 id="IO与NIO的区别">IO与NIO的区别</h2><p>主要区别如下:<br><img src="http://7xiwca.com1.z0.glb.clouddn.com/NIOwithIO.png" alt="NIOwithIO" title="NIOwithIO"></p>
<p>面相流 与 面相缓冲：<br>    NIO与IO的最大区别就是IO面相流，而NIO面相缓冲。面相流意味着每次从流中读取一个或多个字节，直到读取所有字节，这些字节没有被缓存在任何地方，并且不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓冲到一个缓存区。<br>    而NIO的缓冲导向方法略有不同，数据读取到一个稍后用来处理的缓冲区，需要时可在缓冲区中进行前后移动。这就增加了处理过程中的灵活性。</p>
<p>阻塞与非阻塞IO：<br>    IO中的各种流式阻塞的。当一个线程调用read()或write()时，该线程阻塞，直到有一些数据被读取，或数据完全写入，该线程在此期间不能做别的任务。<br>    而NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，目前没有可用诗句时，就什么都不会获取。而不是保持线程阻塞，所以直到数据变得可以读之前，该线程可以继续做其他事情，非阻塞写也是同样。</p>
<p>选择器Selector：<br>    NIO的选择器允许一个单独的线程监视多个通道，即你可以注册多个channel到一个选择器，然后使用一个单独的线程来选择通道：这些通道里已经有可以处理的输入，或者选择已准备写入的通道。</p>
<h2 id="Channel通道">Channel通道</h2><p>NIO类似于流，但又有所不同：</p>
<ul>
<li>既可以从通道中读取数据，又可以写入到通道中，但流的处理只能是单向的。</li>
<li>通道可以异步的读写。</li>
<li>通道中的数据总是要先读到一个buffer，或者总是要从一个buffer中写入。</li>
</ul>
<p>几种重要的Channel实现：</p>
<pre><code>-<span class="ruby"> <span class="constant">FileChannel</span>：从文件中读写数据。
</span>-<span class="ruby"> <span class="constant">DatagramChannel</span>：通过<span class="constant">UDP</span>读写网络中的数据。
</span>-<span class="ruby"> <span class="constant">SocketChannel</span>：通过<span class="constant">TCP</span>读写网络中的数据。
</span>-<span class="ruby"> <span class="constant">ServerSocketChannel</span>：可以监听新进来的<span class="constant">TCP</span>连接，像web服务器一样，对每个新进来的连接都会创建一个<span class="constant">SocketChannel</span>。</span>
</code></pre><p>Example：</p>
<pre><code><span class="label">RandomAccessFile</span> aFile = new RandomAccessFile(<span class="string">"data/nio-data.txt"</span>, <span class="string">"rw"</span>)<span class="comment">;</span>
<span class="label">FileChannel</span> inChannel = aFile.getChannel()<span class="comment">;</span>
<span class="keyword">ByteBuffer </span><span class="keyword">buf </span>= <span class="keyword">ByteBuffer.allocate(48);
</span><span class="label">int</span> <span class="keyword">bytesRead </span>= inChannel.read(<span class="keyword">buf);
</span><span class="label">while</span>(<span class="keyword">bytesRead </span>!= -<span class="number">1</span>){
    System.out.println(<span class="string">"Read "</span> + <span class="keyword">bytesRead);
</span>    <span class="keyword">buf.flip();
</span>    <span class="preprocessor">while</span>(<span class="keyword">buf.hasRemaining()){
</span>        System.out.println((char) <span class="keyword">buf.get());
</span>    }
    <span class="keyword">buf.clear();
</span>    <span class="keyword">bytesRead </span>= inChannel.read(<span class="keyword">buf);
</span>}
<span class="label">aFile.close</span>()
</code></pre><p>注意上面flip()的调用，首先读取数据到buffer，然后翻转buffer，然后从buffer中读取数据。</p>
<h2 id="Buffer缓冲区">Buffer缓冲区</h2><p>使用Buffer读写数据一般遵循四个步骤：<br>1 写入数据到buffer<br>2 调用flip()方法<br>3 从buffer中读取数据<br>4 调用clear()方法或compact()方法</p>
<p>当向buffer写入数据时，buffer会记录下写入了多少数据。一旦要读取数据，通过flip()方法将buffer从写模式切换到读模式，在读模式下，可以读取之前写入到buffer的所有数据。<br>一旦读完了所有数据，就需要清空缓冲区，让它可以被再次写入。有两种方式能够清空缓冲区：调用clear或compact。clear会清空整个缓冲区，compact只会清空已读取过的数据，任何未读取的数据都被移到缓冲区的起始处，新写入的数据将放到缓冲区中未读取部分的后面。</p>
<p>Example：</p>
<pre><code><span class="label">RandomAccessFile</span> aFile = new RandomAccessFile(<span class="string">"data/nio-data.txt"</span>, <span class="string">"rw"</span>)<span class="comment">;  </span>
<span class="label">FileChannel</span> inChannel = aFile.getChannel()<span class="comment">;  </span>

//create <span class="keyword">buffer </span>with capacity of <span class="number">48</span> <span class="keyword">bytes </span> 
<span class="keyword">ByteBuffer </span><span class="keyword">buf </span>= <span class="keyword">ByteBuffer.allocate(48); </span> 

<span class="label">int</span> <span class="keyword">bytesRead </span>= inChannel.read(<span class="keyword">buf); </span>//read into <span class="keyword">buffer. </span> 
<span class="label">while</span> (<span class="keyword">bytesRead </span>!= -<span class="number">1</span>) {  

  <span class="keyword">buf.flip(); </span> //make <span class="keyword">buffer </span>ready for read  

  <span class="preprocessor">while</span>(<span class="keyword">buf.hasRemaining()){ </span> 
      System.out.print((char) <span class="keyword">buf.get()); </span>// read <span class="number">1</span> <span class="keyword">byte </span>at a time  
  }  

  <span class="keyword">buf.clear(); </span>//make <span class="keyword">buffer </span>ready for writing  
  <span class="keyword">bytesRead </span>= inChannel.read(<span class="keyword">buf); </span> 
}  
<span class="label">aFile.close</span>()<span class="comment">; </span>
</code></pre><h3 id="Buffer的capacity,position和limit">Buffer的capacity,position和limit</h3><p>缓冲区本质上是一块可以写入数据，然后可以从中读取数据的内存。这块内存被包装成NIO buffer的对象，并提供一些方法以方便的访问这块内存。<br>Buffer的三个属性：</p>
<ul>
<li>capacity：容量</li>
<li>position：位置</li>
<li>limit：限制</li>
</ul>
<p>position和limit的含义取决于Buffer处在读模式还是写模式。不管Buffer处在什么模式，capacity的含义总是一样的。</p>
<p>capacity：<br>    作为一块内存，buffer有一个固定的大小值，只能往里写入capacity数量的byte、long，char等类型数据，一旦buffer满了，就需要清空(通过读数据或清除数据)才能继续往里写数据。</p>
<p>position：<br>    当写数据到buffer中时，position表示当前的位置。初始状态下position为0，当一个byte或long等类型的数据写入到buffer后，position会向前移动到下一个可插入数据的buffer单元，position最大可为 capacity -1。当读取数据时，也是从某个特定位置读取。当buffer从写模式切换到读模式，position会被重置为0。当从buffer的position读取到数据时，position向前移动到写一个可读位置。</p>
<p>limit：<br>    在写模式下，buffer的limit表示你能往buffer中写入多少数据，即写模式下，其limit等于其capacity。当切换到读模式时，limit表示你最多能读取到多少数据。因此，当切换到读模式时，limit会被设置成写模式时的position值，即写模式时写入了多少数据，读模式是就能读到多少数据。</p>
<h3 id="Buffer的分配">Buffer的分配</h3><p>要想获得一个Buffer对象首先要进行分配。 每一个Buffer类都有一个allocate方法。下面是一个分配48字节capacity的ByteBuffer的例子。</p>
<pre><code><span class="keyword">ByteBuffer </span><span class="keyword">buf </span>= <span class="keyword">ByteBuffer.allocate(48); </span>
</code></pre><p>这是分配一个可存储1024个字符的CharBuffer： </p>
<pre><code><span class="label">CharBuffer</span> <span class="keyword">buf </span>= CharBuffer.allocate(<span class="number">1024</span>)<span class="comment">;  </span>
</code></pre><h3 id="向Buffer写入数据">向Buffer写入数据</h3><p>写数据到buffer有两种方式：<br>1 从channel写到buffer<br>2 通过Buffer的put方法写到buffer里</p>
<p>从channel写入buffer：</p>
<pre><code><span class="keyword">int</span> bytesRead = inChannel.<span class="keyword">read</span>(buf); //<span class="keyword">read</span> into <span class="keyword">buffer</span>.  
</code></pre><p>通过put方法写Buffer的例子：</p>
<pre><code>buf.<span class="keyword">put</span>(<span class="number">127</span>);  
</code></pre><p>flip()方法 ：<br>    flip方法将Buffer从写模式切换到读模式。调用flip()方法会将position设回0，并将limit设置成之前position的值。</p>
<h3 id="从Buffer中读取数据">从Buffer中读取数据</h3><p>从Buffer中读取数据有两种方式：<br>1 从Buffer读取数据到Channel。<br>2 使用get()方法从Buffer中读取数据。</p>
<p>从Buffer读取数据到Channel的例子： </p>
<pre><code>//<span class="keyword">read</span> from <span class="keyword">buffer</span> into channel.  
<span class="keyword">int</span> bytesWritten = inChannel.<span class="keyword">write</span>(buf);
</code></pre><p>使用get()方法从Buffer中读取数据的例子：</p>
<pre><code><span class="keyword">byte</span> aByte = buf.<span class="keyword">get</span>();
</code></pre><p>rewind()方法 ：<br>    Buffer.rewind()将position设回0，所以你可以重读Buffer中的所有数据。limit保持不变，仍然表示能从Buffer中读取多少个元素（byte、char等）。</p>
<p>clear()与compact()方法：</p>
<ul>
<li>一旦读完Buffer中的数据，需要让Buffer准备好再次被写入。可以通过clear()或compact()方法来完成。 </li>
<li>如果调用的是clear()方法，position将被设回0，limit被设置成 capacity的值。换句话说，Buffer 被清空了。Buffer中的数据并未清除，只是这些标记告诉我们可以从哪里开始往Buffer里写数据。</li>
<li>如果Buffer中有一些未读的数据，调用clear()方法，数据将“被遗忘”，意味着不再有任何标记会告诉你哪些数据被读过，哪些还没有。</li>
<li>如果Buffer中仍有未读的数据，且后续还需要这些数据，但是此时想要先先写些数据，那么使用compact()方法。</li>
<li>compact()方法将所有未读的数据拷贝到Buffer起始处。然后将position设到最后一个未读元素正后面。limit属性依然像clear()方法一样，设置成capacity。现在Buffer准备好写数据了，但是不会覆盖未读的数据。</li>
</ul>
<p>mark()与reset()方法：<br>通过调用Buffer.mark()方法，可以标记Buffer中的一个特定position。之后可以通过调用Buffer.reset()方法恢复到这个position。例如：     </p>
<pre><code>buffer.mark();  
//<span class="operator"><span class="keyword">call</span> buffer.<span class="keyword">get</span>() a couple <span class="keyword">of</span> times, <span class="keyword">e</span>.<span class="keyword">g</span>. during parsing.  
buffer.<span class="keyword">reset</span>();</span>  //<span class="operator"><span class="keyword">set</span> <span class="keyword">position</span> back <span class="keyword">to</span> mark. </span>
</code></pre><p>equals()与compareTo()方法 ：<br>    可以使用equals()和compareTo()方法比较两个Buffer。</p>
<p>equals()：<br>当满足下列条件时，表示两个Buffer相等： </p>
<ul>
<li>有相同的类型（byte、char、int等）。</li>
<li>Buffer中剩余的byte、char等的个数相等。</li>
<li>Buffer中所有剩余的byte、char等都相同。</li>
</ul>
<p>如你所见，equals只是比较Buffer的一部分，不是每一个在它里面的元素都比较。实际上，它只比较Buffer中的剩余元素。</p>
<p>compareTo()方法 ：<br>compareTo()方法比较两个Buffer的剩余元素(byte、char等)， 如果满足下列条件，则认为一个Buffer“小于”另一个Buffer： </p>
<ul>
<li>第一个不相等的元素小于另一个Buffer中对应的元素。</li>
<li>所有元素都相等，但第一个Buffer比另一个先耗尽(第一个Buffer的元素个数比另一个少)。</li>
</ul>
<h2 id="分散（Scatter）/聚集（Gather）">分散（Scatter）/聚集（Gather）</h2><p>Java NIO开始支持scatter/gather，scatter/gather用于描述从Channel（译者注：Channel在中文经常翻译为通道）中读取或者写入到Channel的操作。<br>分散（scatter）从Channel中读取是指在读操作时将读取的数据写入多个buffer中。因此，Channel将从Channel中读取的数据“分散（scatter）”到多个Buffer中。<br>聚集（gather）写入Channel是指在写操作时将多个buffer的数据写入同一个Channel，因此，Channel 将多个Buffer中的数据“聚集（gather）”后发送到Channel。<br>scatter / gather经常用于需要将传输的数据分开处理的场合，例如传输一个由消息头和消息体组成的消息，你可能会将消息体和消息头分散到不同的buffer中，这样你可以方便的处理消息头和消息体。</p>
<h3 id="Scattering_Reads">Scattering Reads</h3><p>Example：</p>
<pre><code><span class="keyword">ByteBuffer </span>header = <span class="keyword">ByteBuffer.allocate(128); </span> 
<span class="keyword">ByteBuffer </span><span class="keyword">body </span>  = <span class="keyword">ByteBuffer.allocate(1024); </span>   
<span class="keyword">ByteBuffer[] </span><span class="keyword">bufferArray </span>= { header, <span class="keyword">body </span>}<span class="comment">;  </span>
<span class="label">channel.read</span>(<span class="keyword">bufferArray); </span>
</code></pre><p>注意buffer首先被插入到数组，然后再将数组作为channel.read() 的输入参数。read()方法按照buffer在数组中的顺序将从channel中读取的数据写入到buffer，当一个buffer被写满后，channel紧接着向另一个buffer中写。<br>Scattering Reads在移动下一个buffer前，必须填满当前的buffer，这也意味着它不适用于动态消息(译者注：消息大小不固定)。换句话说，如果存在消息头和消息体，消息头必须完成填充（例如 128byte），Scattering Reads才能正常工作。</p>
<h3 id="Gathering_Writes">Gathering Writes</h3><p>Example：</p>
<pre><code><span class="keyword">ByteBuffer </span>header = <span class="keyword">ByteBuffer.allocate(128); </span> 
<span class="keyword">ByteBuffer </span><span class="keyword">body </span>  = <span class="keyword">ByteBuffer.allocate(1024); </span> 
//write <span class="preprocessor">data</span> into <span class="keyword">buffers </span> 
<span class="keyword">ByteBuffer[] </span><span class="keyword">bufferArray </span>= { header, <span class="keyword">body </span>}<span class="comment">;  </span>
<span class="label">channel.write</span>(<span class="keyword">bufferArray); </span> 
</code></pre><p>buffers数组是write()方法的入参，write()方法会按照buffer在数组中的顺序，将数据写入到channel，注意只有position和limit之间的数据才会被写入。因此，如果一个buffer的容量为128byte，但是仅仅包含58byte的数据，那么这58byte的数据将被写入到channel中。因此与Scattering Reads相反，Gathering Writes能较好的处理动态消息。</p>
<h2 id="通道之间的数据传输">通道之间的数据传输</h2><p>在Java NIO中，如果两个通道中有一个是FileChannel，那你可以直接将数据从一个channel传输到另外一个channel。</p>
<p>transferFrom() ：FileChannel的transferFrom()方法可以将数据从源通道传输到FileChannel中。</p>
<pre><code>RandomAccessFile <span class="keyword">from</span>File = new RandomAccessFile(<span class="string">"fromFile.txt"</span>, <span class="string">"rw"</span>);  
FileChannel      <span class="keyword">from</span>Channel = <span class="keyword">from</span>File.getChannel();  

RandomAccessFile <span class="keyword">to</span>File = new RandomAccessFile(<span class="string">"toFile.txt"</span>, <span class="string">"rw"</span>);  
FileChannel      <span class="keyword">to</span>Channel = <span class="keyword">to</span>File.getChannel();  

long position = <span class="number">0</span>;  
long count = <span class="keyword">from</span>Channel.size();  

<span class="keyword">to</span>Channel.transferFrom(position, count, <span class="keyword">from</span>Channel); 
</code></pre><p>方法的输入参数position表示从position处开始向目标文件写入数据，count表示最多传输的字节数。如果源通道的剩余空间小于count 个字节，则所传输的字节数要小于请求的字节数。<br>此外要注意，在SoketChannel的实现中，SocketChannel只会传输此刻准备好的数据（可能不足count字节）。因此，SocketChannel可能不会将请求的所有数据(count个字节)全部传输到FileChannel中</p>
<p>transferTo() ：将数据从FileChannel传输到其他的channel中。</p>
<pre><code>RandomAccessFile <span class="keyword">from</span>File = new RandomAccessFile(<span class="string">"fromFile.txt"</span>, <span class="string">"rw"</span>);  
FileChannel      <span class="keyword">from</span>Channel = <span class="keyword">from</span>File.getChannel();  

RandomAccessFile <span class="keyword">to</span>File = new RandomAccessFile(<span class="string">"toFile.txt"</span>, <span class="string">"rw"</span>);  
FileChannel      <span class="keyword">to</span>Channel = <span class="keyword">to</span>File.getChannel();  

long position = <span class="number">0</span>;  
long count = <span class="keyword">from</span>Channel.size();  

<span class="keyword">from</span>Channel.transferTo(position, count, <span class="keyword">to</span>Channel); 
</code></pre><h2 id="选择器（Selector）">选择器（Selector）</h2><p>Selector（选择器）是Java NIO中能够检测一到多个NIO通道，并能够知晓通道是否为诸如读写事件做好准备的组件。这样，一个单独的线程可以管理多个channel，从而管理多个网络连接。</p>
<p>通过调用Selector.open()方法创建一个Selector，如下： </p>
<pre><code><span class="keyword">Selector </span><span class="keyword">selector </span>= <span class="keyword">Selector.open(); </span>
</code></pre><p>向Selector注册通道：为了将Channel和Selector配合使用，必须将channel注册到selector上。通过SelectableChannel.register()方法来实现，如下：</p>
<pre><code>channel.configureBlocking(<span class="keyword">false</span>);  
SelectionKey key = channel.<span class="keyword">register</span>(<span class="keyword">selector</span>, Selectionkey.OP_READ);
</code></pre><p>与Selector一起使用时，Channel必须处于非阻塞模式下。这意味着不能将FileChannel与Selector一起使用，因为FileChannel不能切换到非阻塞模式。而套接字通道都可以。<br>注意register()方法的第二个参数。这是一个“interest集合”，意思是在通过Selector监听Channel时对什么事件感兴趣。<br>可以监听四种不同类型的事件：<br>1 Connect<br>2 Accept<br>3 Read<br>4 Write</p>
<p>通道触发了一个事件意思是该事件已经就绪。<br>所以，某个channel成功连接到另一个服务器称为“连接就绪”。<br>一个server socket channel准备好接收新进入的连接称为“接收就绪”。<br>一个有数据可读的通道可以说是“读就绪”。<br>等待写数据的通道可以说是“写就绪”。<br>这四种事件用SelectionKey的四个常量来表示：<br>1 SelectionKey.OP_CONNECT<br>2 SelectionKey.OP_ACCEPT<br>3 SelectionKey.OP_READ<br>4 SelectionKey.OP_WRITE</p>
<p>如果你对不止一种事件感兴趣，那么可以用“位或”操作符将常量连接起来，如下：</p>
<pre><code>int interestSet = SelectionKey.OP_READ <span class="string">| SelectionKey.OP_WRITE; </span>
</code></pre><p>SelectionKey：<br>当向Selector注册Channel时，register()方法会返回一个SelectionKey对象。这个对象包含了一些你感兴趣的属性：<br>interest集合：你所选择的感兴趣的事件集合。可以通过SelectionKey读写interest集合，像这样：</p>
<pre><code><span class="label">int</span> interestSet = <span class="keyword">selectionKey.interestOps(); </span> 
<span class="keyword">boolean </span>isInterestedInAccept  = (interestSet &amp; <span class="keyword">SelectionKey.OP_ACCEPT) </span>== <span class="keyword">SelectionKey.OP_ACCEPT； </span> 
<span class="keyword">boolean </span>isInterestedInConnect = interestSet &amp; <span class="keyword">SelectionKey.OP_CONNECT; </span> 
<span class="keyword">boolean </span>isInterestedInRead    = interestSet &amp; <span class="keyword">SelectionKey.OP_READ; </span> 
<span class="keyword">boolean </span>isInterestedInWrite   = interestSet &amp; <span class="keyword">SelectionKey.OP_WRITE; </span>
</code></pre><p>ready集合：通道已经准备就绪的操作的集合。在一次选择(Selection)之后，你会首先访问这个ready set。访问方式：</p>
<pre><code><span class="built_in">int</span> readySet = selectionKey.readyOps<span class="literal">()</span>; 
同样可以用以下四种方法检测哪种事件就绪了：

selectionKey.isAcceptable<span class="literal">()</span>;  
selectionKey.isConnectable<span class="literal">()</span>;  
selectionKey.isReadable<span class="literal">()</span>;  
selectionKey.isWritable<span class="literal">()</span>; 
</code></pre><p>Channel<br>Selector<br>附加的对象（可选</p>
<p>Channel + Selector：<br>从SelectionKey访问Channel和Selector很简单。如下： </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Channel</span>  channel  = selectionKey.channel();  </span><br><span class="line"><span class="type">Selector</span> selector = selectionKey.selector();</span><br></pre></td></tr></table></figure>
<p>通过Selector选择通道：<br>    一旦向Selector注册了一或多个通道，就可以调用几个重载的select()方法。这些方法返回你所感兴趣的事件（如连接、接受、读或写）已经准备就绪的那些通道。换句话说，如果你对“读就绪”的通道感兴趣，select()方法会返回读事件已经就绪的那些通道。</p>
<p>wakeUp() ：<br>    某个线程调用select()方法后阻塞了，即使没有通道已经就绪，也有办法让其从select()方法返回。只要让其它线程在第一个线程调用select()方法的那个对象上调用Selector.wakeup()方法即可。阻塞在select()方法上的线程会立马返回。<br>    如果有其它线程调用了wakeup()方法，但当前没有线程阻塞在select()方法上，下个调用select()方法的线程会立即“醒来（wake up）”。</p>
<p>close() ：<br>    用完Selector后调用其close()方法会关闭该Selector，且使注册到该Selector上的所有SelectionKey实例无效。同时通道本身并不会关闭。</p>
<p>完整的示例，这里有一个完整的示例，打开一个Selector，注册一个通道注册到这个Selector上(通道的初始化过程略去),然后持续监控这个Selector的四种事件（接受，连接，读，写）是否就绪。</p>
<pre><code>Selector selector = Selector.<span class="built_in">open</span>();  
channel.configureBlocking(<span class="keyword">false</span>);  
SelectionKey <span class="variable">key</span> = channel.register(selector, SelectionKey.OP_READ);  
<span class="keyword">while</span>(<span class="keyword">true</span>) {  
  <span class="built_in">int</span> readyChannels = selector.select();  
  <span class="keyword">if</span>(readyChannels == <span class="number">0</span>) <span class="keyword">continue</span>;  
  Set selectedKeys = selector.selectedKeys();  
  Iterator keyIterator = selectedKeys.iterator();  
  <span class="keyword">while</span>(keyIterator.hasNext()) {  
    SelectionKey <span class="variable">key</span> = keyIterator.next();  
    <span class="keyword">if</span>(<span class="variable">key</span>.isAcceptable()) {  
        <span class="comment">// a connection was accepted by a ServerSocketChannel.  </span>
    } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable">key</span>.isConnectable()) {  
        <span class="comment">// a connection was established with a remote server.  </span>
    } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable">key</span>.isReadable()) {  
        <span class="comment">// a channel is ready for reading  </span>
    } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable">key</span>.isWritable()) {  
        <span class="comment">// a channel is ready for writing  </span>
    }  
    keyIterator.&lt;tuihighlight class=<span class="string">"tuihighlight"</span>&gt;&lt;a href=<span class="string">"javascript:;"</span> style=<span class="string">"display:inline;float:none;position:inherit;cursor:pointer;color:#7962D5;text-decoration:underline;"</span> onclick=<span class="string">"return false;"</span>&gt;remove&lt;/a&gt;&lt;/tuihighlight&gt;();  
  }  
}
</code></pre><h2 id="文件通道">文件通道</h2><p>Java NIO中的FileChannel是一个连接到文件的通道。可以通过文件通道读写文件。<br>FileChannel无法设置为非阻塞模式，它总是运行在阻塞模式下。 </p>
<p>打开FileChannel<br>在使用FileChannel之前，必须先打开它。但是，我们无法直接打开一个FileChannel，需要通过使用一个InputStream、OutputStream或RandomAccessFile来获取一个FileChannel实例。下面是通过RandomAccessFile打开FileChannel的示例：</p>
<pre><code><span class="title">RandomAccessFile</span> aFile = new RandomAccessFile(<span class="string">"data/nio-data.txt"</span>, <span class="string">"rw"</span>);  
<span class="title">FileChannel</span> inChannel = aFile.getChannel();  
</code></pre><p>从FileChannel读取数据<br>调用多个read()方法之一从FileChannel中读取数据。如： </p>
<pre><code><span class="keyword">ByteBuffer </span><span class="keyword">buf </span>= <span class="keyword">ByteBuffer.allocate(48); </span> 
<span class="label">int</span> <span class="keyword">bytesRead </span>= inChannel.read(<span class="keyword">buf); </span>
</code></pre><p>向FileChannel写数据<br>使用FileChannel.write()方法向FileChannel写数据，该方法的参数是一个Buffer。如： </p>
<pre><code><span class="keyword">String </span>newData = <span class="string">"New String to write to file..."</span> + System.currentTimeMillis()<span class="comment">;  </span>

<span class="keyword">ByteBuffer </span><span class="keyword">buf </span>= <span class="keyword">ByteBuffer.allocate(48); </span> 
<span class="keyword">buf.clear(); </span> 
<span class="keyword">buf.put(newData.getBytes()); </span> 

<span class="keyword">buf.flip(); </span> 

<span class="label">while</span>(<span class="keyword">buf.hasRemaining()) </span>{  
    channel.write(<span class="keyword">buf); </span> 
}
</code></pre><p>注意FileChannel.write()是在while循环中调用的。因为无法保证write()方法一次能向FileChannel写入多少字节，因此需要重复调用write()方法，直到Buffer中已经没有尚未写入通道的字节。</p>
<p>关闭FileChannel<br>用完FileChannel后必须将其关闭。如：</p>
<pre><code><span class="tag">channel</span><span class="class">.close</span>();
</code></pre><p>FileChannel的position方法 </p>
<pre><code><span class="keyword">long</span> pos = channel.position();  
channel.position(pos +<span class="number">123</span>); 
</code></pre><p>FileChannel的size方法 ：FileChannel实例的size()方法将返回该实例所关联文件的大小。</p>
<pre><code><span class="keyword">long</span> fileSize = channel.<span class="keyword">size</span>();
</code></pre><p>FileChannel的truncate方法 ：可以使用FileChannel.truncate()方法截取一个文件。截取文件时，文件将中指定长度后面的部分将被删除。</p>
<pre><code>channel.truncate(<span class="number">1024</span>);
</code></pre><p>FileChannel的force方法<br>FileChannel.force()方法将通道里尚未写入磁盘的数据强制写到磁盘上。出于性能方面的考虑，操作系统会将数据缓存在内存中，所以无法保证写入到FileChannel里的数据一定会即时写到磁盘上。要保证这一点，需要调用force()方法。<br>force()方法有一个boolean类型的参数，指明是否同时将文件元数据（权限信息等）写到磁盘上。<br>下面的例子同时将文件数据和元数据强制写到磁盘上：</p>
<pre><code>channel.<span class="literal">force</span>(<span class="literal">true</span>)<span class="comment">;</span>
</code></pre><h2 id="Socket_通道">Socket 通道</h2><p>Java NIO中的SocketChannel是一个连接到TCP网络套接字的通道。可以通过以下2种方式创建SocketChannel：<br>    打开一个SocketChannel并连接到互联网上的某台服务器。<br>    一个新连接到达ServerSocketChannel时，会创建一个SocketChannel。</p>
<p>打开 SocketChannel<br>下面是SocketChannel的打开方式：</p>
<pre><code>SocketChannel socketChannel = SocketChannel.open();  
socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"http://jenkov.com"</span>, <span class="number">80</span>));
</code></pre><p>关闭 SocketChannel<br>当用完SocketChannel之后调用SocketChannel.close()关闭SocketChannel： </p>
<pre><code><span class="tag">socketChannel</span><span class="class">.close</span>();
</code></pre><p>从 SocketChannel 读取数据<br>要从SocketChannel中读取数据，调用一个read()的方法之一。以下是例子：</p>
<pre><code><span class="keyword">ByteBuffer </span><span class="keyword">buf </span>= <span class="keyword">ByteBuffer.allocate(48); </span> 
<span class="label">int</span> <span class="keyword">bytesRead </span>= socketChannel.read(<span class="keyword">buf); </span>
</code></pre><p>首先，分配一个Buffer。从SocketChannel读取到的数据将会放到这个Buffer中。<br>然后，调用SocketChannel.read()。该方法将数据从SocketChannel 读到Buffer中。read()方法返回的int值表示读了多少<br>字节进Buffer里。如果返回的是-1，表示已经读到了流的末尾（连接关闭了）。</p>
<p>写入 SocketChannel<br>写数据到SocketChannel用的是SocketChannel.write()方法，该方法以一个Buffer作为参数。示例如下：</p>
<pre><code><span class="keyword">String </span>newData = <span class="string">"New String to write to file..."</span> + System.currentTimeMillis()<span class="comment">;  </span>

<span class="keyword">ByteBuffer </span><span class="keyword">buf </span>= <span class="keyword">ByteBuffer.allocate(48); </span> 
<span class="keyword">buf.clear(); </span> 
<span class="keyword">buf.put(newData.getBytes()); </span> 

<span class="keyword">buf.flip(); </span> 

<span class="label">while</span>(<span class="keyword">buf.hasRemaining()) </span>{  
    channel.write(<span class="keyword">buf); </span> 
}
</code></pre><p>注意SocketChannel.write()方法的调用是在一个while循环中的。Write()方法无法保证能写多少字节到SocketChannel。<br>所以，我们重复调用write()直到Buffer没有要写的字节为止。 </p>
<p>非阻塞模式<br>可以设置 SocketChannel 为非阻塞模式（non-blocking mode）.设置之后，就可以在异步模式下调用connect(), read()和write()了。</p>
<p>connect()<br>如果SocketChannel在非阻塞模式下，此时调用connect()，该方法可能在连接建立之前就返回了。为了确定连接是否建立，可以<br>调用finishConnect()的方法。像这样：</p>
<pre><code>socketChannel.configureBlocking(<span class="literal">false</span>);  
socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"http://jenkov.com"</span>, <span class="number">80</span>));  

<span class="keyword">while</span>(! socketChannel.finishConnect() ){  
    <span class="regexp">//</span>wait, <span class="keyword">or</span> <span class="keyword">do</span> something <span class="keyword">else</span>...  
}
</code></pre><p>write()<br>非阻塞模式下，write()方法在尚未写出任何内容时可能就返回了。所以需要在循环中调用write()。前面已经有例子了，这里就不赘述了。</p>
<p>read()<br>非阻塞模式下,read()方法在尚未读取到任何数据时可能就返回了。所以需要关注它的int返回值，它会告诉你读取了多少字节。 </p>
<p>非阻塞模式与选择器<br>非阻塞模式与选择器搭配会工作的更好，通过将一或多个SocketChannel注册到Selector，可以询问选择器哪个通道已经准备好了读取，写入等。Selector与SocketChannel的搭配使用会在后面详讲。</p>
</span>
      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/NIO/" rel="tag">#NIO</a>
          
            <a href="/tags/java/" rel="tag">#java</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-prev post-nav-item">
            
              <a href="/2015/09/30/Simple-Scala-Asynchronous-HTTP-requests-with-Scala-and-Dispatch/" rel="prev">Simple Scala: Asynchronous HTTP requests with Scala and Dispatch</a>
            
          </div>

          <div class="post-nav-next post-nav-item">
            
              <a href="/2015/09/29/Simple-MongoDB-Basics/" rel="next">Simple MongoDB: Basics</a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

 </div>

        

        
          <div class="comments" id="comments">
            
          </div>
        
      </div>

      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="http://7xiwca.com1.z0.glb.clouddn.com/headpicture.gif" alt="Zhange" itemprop="image"/>
          <p class="site-author-name" itemprop="name">Zhange</p>
        </div>
        <p class="site-description motion-element" itemprop="description">Zhange's notes</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">60</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            
              <span class="site-state-item-count">0</span>
              <span class="site-state-item-name">分类</span>
              
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">28</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      
        <section class="post-toc-wrap sidebar-panel-active">
          <div class="post-toc-indicator-top post-toc-indicator"></div>
          <div class="post-toc">
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#简介"><span class="nav-number">1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NIO核心"><span class="nav-number">2.</span> <span class="nav-text">NIO核心</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IO与NIO的区别"><span class="nav-number">3.</span> <span class="nav-text">IO与NIO的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Channel通道"><span class="nav-number">4.</span> <span class="nav-text">Channel通道</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Buffer缓冲区"><span class="nav-number">5.</span> <span class="nav-text">Buffer缓冲区</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Buffer的capacity,position和limit"><span class="nav-number">5.1.</span> <span class="nav-text">Buffer的capacity,position和limit</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Buffer的分配"><span class="nav-number">5.2.</span> <span class="nav-text">Buffer的分配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#向Buffer写入数据"><span class="nav-number">5.3.</span> <span class="nav-text">向Buffer写入数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#从Buffer中读取数据"><span class="nav-number">5.4.</span> <span class="nav-text">从Buffer中读取数据</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分散（Scatter）/聚集（Gather）"><span class="nav-number">6.</span> <span class="nav-text">分散（Scatter）/聚集（Gather）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Scattering_Reads"><span class="nav-number">6.1.</span> <span class="nav-text">Scattering Reads</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Gathering_Writes"><span class="nav-number">6.2.</span> <span class="nav-text">Gathering Writes</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#通道之间的数据传输"><span class="nav-number">7.</span> <span class="nav-text">通道之间的数据传输</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#选择器（Selector）"><span class="nav-number">8.</span> <span class="nav-text">选择器（Selector）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件通道"><span class="nav-number">9.</span> <span class="nav-text">文件通道</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Socket_通道"><span class="nav-number">10.</span> <span class="nav-text">Socket 通道</span></a></li></ol></div>
            
          </div>
          <div class="post-toc-indicator-bottom post-toc-indicator"></div>
        </section>
      

    </div>
  </aside>


    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner"> <div class="copyright" >
  
  &copy; &nbsp; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="icon-next-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhange</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


 </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  
  
    
    

  


  
  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.1"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.1"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.5.1" id="motion.global"></script>




  <script type="text/javascript" src="/js/nav-toggle.js?v=0.4.5.1"></script>
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  
<script type="text/javascript" src="/js/bootstrap.scrollspy.js?v=0.4.5.1" id="bootstrap.scrollspy.custom"></script>


<script type="text/javascript" id="sidebar.toc.highlight">
  $(document).ready(function () {
    var tocSelector = '.post-toc';
    var $tocSelector = $(tocSelector);
    var activeCurrentSelector = '.active-current';

    $tocSelector
      .on('activate.bs.scrollspy', function () {
        var $currentActiveElement = $(tocSelector + ' .active').last();

        removeCurrentActiveClass();
        $currentActiveElement.addClass('active-current');

        $tocSelector[0].scrollTop = $currentActiveElement.position().top;
      })
      .on('clear.bs.scrollspy', function () {
        removeCurrentActiveClass();
      });

    function removeCurrentActiveClass () {
      $(tocSelector + ' ' + activeCurrentSelector)
        .removeClass(activeCurrentSelector.substring(1));
    }

    function processTOC () {
      getTOCMaxHeight();
      toggleTOCOverflowIndicators();
    }

    function getTOCMaxHeight () {
      var height = $('.sidebar').height() -
                   $tocSelector.position().top -
                   $('.post-toc-indicator-bottom').height();

      $tocSelector.css('height', height);

      return height;
    }

    function toggleTOCOverflowIndicators () {
      tocOverflowIndicator(
        '.post-toc-indicator-top',
        $tocSelector.scrollTop() > 0 ? 'show' : 'hide'
      );

      tocOverflowIndicator(
        '.post-toc-indicator-bottom',
        $tocSelector.scrollTop() >= $tocSelector.find('ol').height() - $tocSelector.height() ? 'hide' : 'show'
      )
    }

    $(document).on('sidebar.motion.complete', function () {
      processTOC();
    });

    $('body').scrollspy({ target: tocSelector });
    $(window).on('resize', function () {
      if ( $('.sidebar').hasClass('sidebar-active') ) {
        processTOC();
      }
    });

    onScroll($tocSelector);

    function onScroll (element) {
      element.on('mousewheel DOMMouseScroll', function (event) {
          var oe = event.originalEvent;
          var delta = oe.wheelDelta || -oe.detail;

          this.scrollTop += ( delta < 0 ? 1 : -1 ) * 30;
          event.preventDefault();

          toggleTOCOverflowIndicators();
      });
    }

    function tocOverflowIndicator (indicator, action) {
      var $indicator = $(indicator);
      var opacity = action === 'show' ? 0.4 : 0;
      $indicator.velocity ?
        $indicator.velocity('stop').velocity({
          opacity: opacity
        }, { duration: 100 }) :
        $indicator.stop().animate({
          opacity: opacity
        }, 100);
    }

  });
</script>

<script type="text/javascript" id="sidebar.nav">
  $(document).ready(function () {
    var html = $('html');
    var TAB_ANIMATE_DURATION = 200;
    var hasVelocity = $.isFunction(html.velocity);

    $('.sidebar-nav li').on('click', function () {
      var item = $(this);
      var activeTabClassName = 'sidebar-nav-active';
      var activePanelClassName = 'sidebar-panel-active';
      if (item.hasClass(activeTabClassName)) {
        return;
      }

      var currentTarget = $('.' + activePanelClassName);
      var target = $('.' + item.data('target'));

      hasVelocity ?
        currentTarget.velocity('transition.slideUpOut', TAB_ANIMATE_DURATION, function () {
          target
            .velocity('stop')
            .velocity('transition.slideDownIn', TAB_ANIMATE_DURATION)
            .addClass(activePanelClassName);
        }) :
        currentTarget.animate({ opacity: 0 }, TAB_ANIMATE_DURATION, function () {
          currentTarget.hide();
          target
            .stop()
            .css({'opacity': 0, 'display': 'block'})
            .animate({ opacity: 1 }, TAB_ANIMATE_DURATION, function () {
              currentTarget.removeClass(activePanelClassName);
              target.addClass(activePanelClassName);
            });
        });

      item.siblings().removeClass(activeTabClassName);
      item.addClass(activeTabClassName);
    });

    $('.post-toc a').on('click', function (e) {
      e.preventDefault();
      var targetSelector = escapeSelector(this.getAttribute('href'));
      var offset = $(targetSelector).offset().top;
      hasVelocity ?
        html.velocity('stop').velocity('scroll', {
          offset: offset  + 'px',
          mobileHA: false
        }) :
        $('html, body').stop().animate({
          scrollTop: offset
        }, 500);
    });

    // Expand sidebar on post detail page by default, when post has a toc.
    var $tocContent = $('.post-toc-content');
    if (isDesktop() && CONFIG.sidebar === 'post') {
      if ($tocContent.length > 0 && $tocContent.html().trim().length > 0) {
        displaySidebar();
      }
    }
  });
</script>



  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
      if (isMobile()) {
        FastClick.attach(document.body);
      }
    });
  </script>

  

  
  

  
  <script type="text/javascript" src="/js/lazyload.js"></script>
  <script type="text/javascript">
    $(function () {
      $("#posts").find('img').lazyload({
        placeholder: "/images/loading.gif",
        effect: "fadeIn"
      });
    });
  </script>
</body>
</html>
