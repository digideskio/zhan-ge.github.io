<!doctype html>
<html class="theme-next use-motion theme-next-mist">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />








  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>




<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.5.1"/>


    <meta name="description" content="Zhange's notes" />



  <meta name="keywords" content="Akka,Scala," />





  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.1" />


<meta name="description" content="Akka集群模式.">
<meta property="og:type" content="article">
<meta property="og:title" content="Simple Akka: Cluster">
<meta property="og:url" content="http://yoursite.com/2016/03/28/Simple-Akka-Cluster/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Akka集群模式.">
<meta property="og:updated_time" content="2016-03-31T15:13:48.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Simple Akka: Cluster">
<meta name="twitter:description" content="Akka集群模式.">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: 'Mist',
    sidebar: 'post'
  };
</script>

  <title> Simple Akka: Cluster | Hexo </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  



  <div class="container one-column page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand" rel="start">
      <span class="logo">
        <i class="icon-next-logo"></i>
      </span>
      <span class="site-title">Zhange's notes</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon icon-next-home"></i> <br />
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            <i class="menu-item-icon icon-next-archives"></i> <br />
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            <i class="menu-item-icon icon-next-tags"></i> <br />
            标签
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content"> 

  <div id="posts" class="posts-expand">
    

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              Simple Akka: Cluster
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2016-03-28T21:07:10+08:00" content="2016-03-28">
            2016-03-28
          </time>
        </span>

        

        
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        <span itemprop="articleBody"><h2 id="简介">简介</h2><p>Akka提供一个高容错,基于点对点的权利分散的集群成员关系,不会出现单点错误或单点瓶颈.基于gossip协议和一个自动的错误检查器实现.</p>
<h3 id="Gossip协议">Gossip协议</h3><p>Gossip算法又被称为反熵(Anti-Entropy),熵物理学上的一种概念,代表杂乱无章,而反熵就是在杂乱无章中寻求一致,这充分说明了Gossip的特点: 在一个有界网络中,每个节点随机的与其他节点通信,经过一番杂乱无章的通信,最终所有的节点都会达成一致.每个节点都可能知道其他节点,也可能只知道一个邻居节点,只要这些节点可以通过网络连通,最终他们的状态都是一致的,当然这也是疫情传播的特点.</p>
<p>要注意的一点是,即使所有的节点因宕机而重启,有新节点加入,但经过一段时间后,这些节点的状态也会与其他节点达成一致,也就是说,Gossip天然具有分布式容错的特点.</p>
<p>Gossip是一个带有冗余的容错算法,更进一步,Gossip是一个最终一致算法.虽然无法保证在某个时刻所有节点状态一致,但可以保证<code>最终</code>所有节点一致,<code>最终</code>是一个现实中存在,但理论上无法证明的时间点.</p>
<p>因为Gossip不要求节点知道所有其他节点,因此又具有去中心化的特点,节点之间完全对等,不需要任何的中心节点.实际上Gossip可以用于众多能接受<code>最终一致性</code>的领域: 失败检测,路由同步,Pub/Sub,动态负载均衡等.</p>
<p>但Gossip的缺点也很明显,冗余通信会对网路带宽和CPU资源造成很大的负载,而这些负载有受限于通信频率,该频率有影响着算法收敛的速度.</p>
<h2 id="术语">术语</h2><ol>
<li>node: 集群的一个逻辑成员,在一个物理机上可以有多个节点.使用一个<code>hostname:port:uid</code>的元组进行定义.</li>
<li>cluster: 一组节点通过成员关系(membership)服务组合在一起构成一个集群.</li>
<li>leader: 集群中有一个单独的节点作为一个领导者<code>leader</code>,管理集群集合和成员关系状态变更.</li>
</ol>
<h2 id="成员关系">成员关系</h2><p>一个集群由多个成员节点组成.每个节点的表示是一个<code>hostname:port:uid</code>的元组.一个Akka应用可以在每个节点host应用的一部分来将整个应用分布的整个集群.成员关系和应用中运行在各节点上的actor是解耦的.一个节点不运行任何actor也可以成为集群的成员.通过向集群中的一个节点发起<code>Join</code>命令来加入集群.</p>
<p>节点标识内部会包含一个UID来独特的标识出在一个<code>hostname:port</code>上的actor系统实例.Akka通过这个UID来触发可靠的远程死亡监控(death watch).这表示一个actor系统在被移出集群之前不能再次被加入到集群中.如果想以相同的<code>hostname:port</code>将一个actor系统加入到集群首先需要关闭该actor系统,然后重新以同样的<code>hostname:port</code>进行加入,这时会受到一个不同的UID.</p>
<p>集群关系状态是一个专业的<code>CRDT(一种最终一致性理论)</code>,他有一个无变化的合并功能.当在多个节点上同时发生多个改变,更新总是会合并并归一到一个相同的最终结果.</p>
<h2 id="Gossip">Gossip</h2><p>Akka中使用的成员关系是基于Amazon的<code>Dynamo</code>系统,特别接近于Basho的<code>Riak</code>分布式数据库.成员关系公国<code>Gossip</code>协议进行通信.</p>
<h2 id="向量时钟(Vector_Clocks)">向量时钟(Vector Clocks)</h2><p><code>Vector Clocks</code>是一个数据结构和算法,用于在分布式系统中生成局部排序的时间和因果错误的探测.</p>
<p>在Akka中用于促使不同集群状态的一致并进行合并.一个<code>Vector Clocks</code>是一个<code>(node, counter)</code>对,每次更新集群状态都会同时更新向量时钟.</p>
<h2 id="Gossip_Convergence">Gossip Convergence</h2><h2 id="Failure_Detector">Failure Detector</h2><h2 id="Leader">Leader</h2><h2 id="Seed_Nodes">Seed Nodes</h2><h2 id="Gossip_Protocol">Gossip Protocol</h2><h2 id="Membership_Lifecycle">Membership Lifecycle</h2><h3 id="成员状态">成员状态</h3><ol>
<li>joining: 加入集群时一个短暂的状态</li>
<li>weakly up: 当网络被隔开时一个短暂的状态(akka.cluster.allow-weakly-up-members=on)</li>
<li>up: 正常的运行状态</li>
<li>leaving / exiting: 被优雅的移除时的状态</li>
<li>down: 被标记为down,不再是集群的一部分</li>
<li>removed: 死亡状态,不再是一个成员</li>
</ol>
<h3 id="用户动作">用户动作</h3><ol>
<li>join: 将一个单节点加入到集群,如果在配置文件中指定的话会在开启时自动加入</li>
<li>leave: 使一个节点优雅的离开集群</li>
<li>down: 将一个节点标记为down</li>
</ol>
<h3 id="Leader动作">Leader动作</h3><ol>
<li><p>改变一个节点加入或离开集群:</p>
<ol>
<li>joining -&gt; up</li>
<li>exiting -&gt; removed</li>
</ol>
</li>
<li><p><code>fd*</code></p>
</li>
<li><code>unreachable*</code></li>
</ol>
<h2 id="添加依赖">添加依赖</h2><p>Akka集群是一个单独的jar文件:</p>
<pre><code><span class="string">"com.typesafe.akka"</span> <span class="preprocessor">%</span><span class="preprocessor">%</span> <span class="string">"akka-cluster"</span> <span class="preprocessor">%</span> <span class="string">"2.4.2"</span>
</code></pre><h2 id="一个简单的集群例子">一个简单的集群例子</h2><p>下面的配置文件用于激活集群扩展:</p>
<pre><code><span class="comment">// application.conf</span>

akka {
  actor {                                           <span class="comment">// 设置actor引用类型</span>
    provider = <span class="string">"akka.cluster.ClusterActorRefProvider"</span>
  }
  remote {                                          <span class="comment">// 激活remote配置</span>
    <span class="keyword">log</span>-remote-lifecycle-events = off
    netty.tcp {
      hostname = <span class="string">"127.0.0.1"</span>                        <span class="comment">// 本地IP</span>
      port = 0
    }
  }

  <span class="keyword">cluster</span> {                                         <span class="comment">// 集群节点信息,这里有两个节点</span>
    seed-nodes = [
      <span class="string">"akka.tcp://ClusterSystem@127.0.0.1:2551"</span>,
      <span class="string">"akka.tcp://ClusterSystem@127.0.0.1:2552"</span>]

    # auto downing is NOT safe <span class="keyword">for</span> production deployments.
    # you may want to <span class="keyword">use</span> it during development, <span class="keyword">read</span> <span class="keyword">more</span> <span class="keyword">about</span> it <span class="keyword">in</span> the docs.
    #
    # auto-down-unreachable-after = 10s
  }
}

# Disable legacy metrics <span class="keyword">in</span> akka-<span class="keyword">cluster</span>.
akka.<span class="keyword">cluster</span>.metrics.enabled=off

# Enable metrics extension <span class="keyword">in</span> akka-<span class="keyword">cluster</span>-metrics.
akka.extensions=[<span class="string">"akka.cluster.metrics.ClusterMetricsExtension"</span>]

# Sigar native library extract location during tests.
# <span class="keyword">Note</span>: <span class="keyword">use</span> per-jvm-instance folder when running multiple jvm <span class="keyword">on</span> <span class="keyword">one</span> host.
akka.<span class="keyword">cluster</span>.metrics.native-library-extract-folder=<span class="label">${user</span>.<span class="keyword">dir</span>}/target/native
</code></pre><p>然后创建一个actor来使用集群扩展:</p>
<pre><code><span class="keyword">package</span> sample.cluster.simple

<span class="keyword">import</span> akka.cluster.<span class="type">Cluster</span>
<span class="keyword">import</span> akka.cluster.<span class="type">ClusterEvent</span>._
<span class="keyword">import</span> akka.actor.<span class="type">ActorLogging</span>
<span class="keyword">import</span> akka.actor.<span class="type">Actor</span>

<span class="class"><span class="keyword">class</span> <span class="title">SimpleClusterListener</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Actor</span> <span class="keyword"><span class="keyword">with</span></span> <span class="title">ActorLogging</span> {</span>

  <span class="function"><span class="keyword">val</span> <span class="title">cluster</span> =</span> <span class="type">Cluster</span>(context.system)

  <span class="comment">// subscribe to cluster changes, re-subscribe when restart </span>
  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">preStart</span>(</span>): <span class="type">Unit</span> = {
    <span class="comment">//#subscribe</span>
    cluster.subscribe(self, initialStateMode = <span class="type">InitialStateAsEvents</span>,
      classOf[<span class="type">MemberEvent</span>], classOf[<span class="type">UnreachableMember</span>])
    <span class="comment">//#subscribe</span>
  }
  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">postStop</span>(</span>): <span class="type">Unit</span> = cluster.unsubscribe(self)

  <span class="function"><span class="keyword">def</span> <span class="title">receive</span> =</span> {
    <span class="keyword">case</span> <span class="type">MemberUp</span>(member) =&gt;
      log.info(<span class="string">"Member is Up: {}"</span>, member.address)
    <span class="keyword">case</span> <span class="type">UnreachableMember</span>(member) =&gt;
      log.info(<span class="string">"Member detected as unreachable: {}"</span>, member)
    <span class="keyword">case</span> <span class="type">MemberRemoved</span>(member, previousStatus) =&gt;
      log.info(<span class="string">"Member is Removed: {} after {}"</span>,
        member.address, previousStatus)
    <span class="keyword">case</span> _: <span class="type">MemberEvent</span> =&gt; <span class="comment">// ignore</span>
  }
}
</code></pre><p>这个actor把自己注册为集群事件的订阅者.当订阅开始时它会收到当前集群中状态改变的事件.</p>
<h2 id="向集群中添加一个节点">向集群中添加一个节点</h2><p>当一个节点启动时,它会发送一个消息到所有节点,然后向返回消息的节点发送一个加入命令.如果其中一个节点回复后(或者其他节点还没有启动),它会一直尝试这个流程,知道成功或者自己被关闭.</p>
<p>在配置文件<code>application.conf</code>中定义所有集群中的节点信息:</p>
<pre><code>akka<span class="class">.cluster</span><span class="class">.seed-nodes</span> = [
  <span class="string">"akka.tcp://ClusterSystem@host1:2552"</span>,
  <span class="string">"akka.tcp://ClusterSystem@host2:2552"</span>]
</code></pre><p>这些节点可以以然和顺序启动并且不用全部都启动.但是当最初启动一个集群时,列表中的第一个节点必须被首先启动,否则其他的节点不会被初始化,也不会被加入到集群中.当启动两个节点以上时第一个节点再被关闭就没有问题了.如果第一个节点被重启,它会首先尝试加入到集群中其他已有的节点.</p>
<p>如果不配置节点信息的话则需要以编程的方式或者手动的方式提供节点信息.</p>
<h2 id="自动或手动关闭">自动或手动关闭</h2><p>默认情况下必须以手动的方式(命令行)关闭集群,或者可以在配置文件中设置为自动方式:</p>
<pre><code>akka<span class="class">.cluster</span><span class="class">.auto-down-unreachable-after</span> = <span class="number">120s</span>
</code></pre><p>这表示集群管理员会自定把连接超时的节点从<code>unreachable</code>状态设置为<code>down</code>状态.</p>
<h2 id="Leaving">Leaving</h2><p>有两种方式从集群中移除一个节点.</p>
<p>首先可以关闭actor系统.</p>
<p>另一种优雅的方式是告诉集群一个节点需要离开,可以通过命令行工具,或者使用编程的方式:</p>
<pre><code>val cluster = <span class="function"><span class="title">Cluster</span><span class="params">(system)</span></span>
cluster.<span class="function"><span class="title">leave</span><span class="params">(cluster.selfAddress)</span></span>
</code></pre><h2 id="WeaklyUp_Members(实验性,仅支持2-4以上的版本)">WeaklyUp Members(实验性,仅支持2.4以上的版本)</h2><p>当一个节点变为<code>unreachable</code>时,我们仍然希望它能够再次激活,这个特性默认是关闭的,可以通过配置文件激活:</p>
<pre><code>akka<span class="class">.cluster</span><span class="class">.allow-weakly-up-members</span> = on
</code></pre><p>激活这个特性后,如果当时没有<code>gossip convergence</code>,<code>Joining</code>状态的成员会变成<code>WeaklyUp</code>同时成为集群的一部分,一旦<code>gossip convergence</code>到达,管理员就会把<code>WeaklyUp</code>的成员改为<code>Up</code>状态.</p>
<h2 id="订阅集群事件">订阅集群事件</h2><p>使用<code>Cluster(system).subscribe</code>可以订阅集群改变的提醒.</p>
<pre><code><span class="tag">cluster</span><span class="class">.subscribe</span>(<span class="tag">self</span>, <span class="tag">classOf</span><span class="attr_selector">[MemberEvent]</span>, <span class="tag">classOf</span><span class="attr_selector">[UnreachableMember]</span>)
</code></pre><p><code>akka.cluster.ClusterEvent.CurrentClusterState</code>,集群完整状态的快照,会作为第一条消息发送到订阅者,后续的时间会发送新的更新.</p>
<p>如果你在join流程完成之前开启订阅,还没有任何成员,这时会受到一个空的<code>CurrentClusterState</code>.</p>
<p>如果不想接收<code>CurrentClusterState</code>,可以使用<code>ClusterEvent.InitialStateAsEvents</code>参数进行订阅,这会发送整个集群中真正作用到集群的过往消息.</p>
<pre><code>cluster.subscribe(self, initialStateMode = InitialStateAsEvents,
  classOf<span class="string">[MemberEvent]</span>, classOf<span class="string">[UnreachableMember]</span>)
</code></pre><p>整个生命周期的轨迹事件包括:</p>
<ol>
<li>ClusterEvent.MemberJoined</li>
<li>ClusterEvent.MemberUp</li>
<li>ClusterEvent.MemberExited</li>
<li>ClusterEvent.MemberRemoved</li>
<li>ClusterEvent.UnreachableMember</li>
<li>ClusterEvent.ReachableMember</li>
</ol>
<p>还有更多别的事件,详细参考API.如果只想获取成员关系状态可以使用<code>Cluster(system).state</code>.</p>
<h2 id="Worker_Dial-in_Example">Worker Dial-in Example</h2><p>这个样例应用用于转换一个文本.当一个文本发送到前端服务时,它会被分发到一个后端工作节点来完成转换工作,然后在把结果返回给原始的客户端.一个新的前端或者后端节点可以动态的向集群添加或移除.</p>
<p>用到的消息:</p>
<pre><code><span class="keyword">final</span> <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">TransformationJob</span>(</span>text: <span class="type">String</span>)
<span class="keyword">final</span> <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">TransformationResult</span>(</span>text: <span class="type">String</span>)
<span class="keyword">final</span> <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">JobFailed</span>(</span>reason: <span class="type">String</span>, job: <span class="type">TransformationJob</span>)
<span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">BackendRegistration</span></span>
</code></pre><p>完成转换工作的后端工作节点:</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">TransformationBackend</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Actor</span> {</span>

  <span class="function"><span class="keyword">val</span> <span class="title">cluster</span> =</span> <span class="type">Cluster</span>(context.system)

  <span class="comment">// subscribe to cluster changes, MemberUp</span>
  <span class="comment">// re-subscribe when restart</span>
  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">preStart</span>(</span>): <span class="type">Unit</span> = cluster.subscribe(self, classOf[<span class="type">MemberUp</span>])
  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">postStop</span>(</span>): <span class="type">Unit</span> = cluster.unsubscribe(self)

  <span class="function"><span class="keyword">def</span> <span class="title">receive</span> =</span> {
    <span class="keyword">case</span> <span class="type">TransformationJob</span>(text) =&gt; sender() ! <span class="type">TransformationResult</span>(text.toUpperCase)
    <span class="keyword">case</span> state: <span class="type">CurrentClusterState</span> =&gt;
      state.members.filter(_.status == <span class="type">MemberStatus</span>.<span class="type">Up</span>) foreach register
    <span class="keyword">case</span> <span class="type">MemberUp</span>(m) =&gt; register(m)
  }

  <span class="function"><span class="keyword">def</span> <span class="title">register</span>(</span>member: <span class="type">Member</span>): <span class="type">Unit</span> =
    <span class="keyword">if</span> (member.hasRole(<span class="string">"frontend"</span>))     <span class="comment">// 检查节点角色</span>
      context.actorSelection(<span class="type">RootActorPath</span>(member.address) / <span class="string">"user"</span> / <span class="string">"frontend"</span>) !
        <span class="type">BackendRegistration</span>
}
</code></pre><p>注意这个<code>TransformationBackend</code>actor订阅了集群事件用于检测新的前端节点,然后给他发送一个注册消息以告诉他们可以使用后端的工作节点了.</p>
<p>前端节点接收转换工作并委派到以注册的后端工作节点:</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">TransformationFrontend</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Actor</span> {</span>

  <span class="keyword">var</span> backends = <span class="type">IndexedSeq</span>.empty[<span class="type">ActorRef</span>]
  <span class="keyword">var</span> jobCounter = <span class="number">0</span>

  <span class="function"><span class="keyword">def</span> <span class="title">receive</span> =</span> {
    <span class="keyword">case</span> job: <span class="type">TransformationJob</span> <span class="keyword">if</span> backends.isEmpty =&gt;
      sender() ! <span class="type">JobFailed</span>(<span class="string">"Service unavailable, try again later"</span>, job)

    <span class="keyword">case</span> job: <span class="type">TransformationJob</span> =&gt;
      jobCounter += <span class="number">1</span>
      backends(jobCounter % backends.size) forward job

    <span class="keyword">case</span> <span class="type">BackendRegistration</span> <span class="keyword">if</span> !backends.contains(sender()) =&gt;
      context watch sender()
      backends = backends :+ sender()

    <span class="keyword">case</span> <span class="type">Terminated</span>(a) =&gt;
      backends = backends.filterNot(_ == a)
  }
}
</code></pre><p>注意前端节点使用<code>watch</code>监控了已注册的节点,以便他们关闭时会发来<code>Terminated</code>消息从而将该关闭的节点从可用节点列表中移除.</p>
<h2 id="节点角色">节点角色</h2><p>并不是所有的节点都需要提供所有的功能: 一些用于运行web前端,一些运行数据库访问层,一些用于计数.部署actor时提供角色信息可以将节点的角色归档以进行职责分配.</p>
<p>节点角色在配置文件的<code>akka.cluster.roles</code>属性中定义,通常定义在系统启动脚本或环境变量中.</p>
<p>节点角色同样是<code>MemberEvent</code>成员关系信息的一部分,可以进行订阅.</p>
<h2 id="How_To_Startup_when_Cluster_Size_Reached">How To Startup when Cluster Size Reached</h2><p>一个普遍的用例是当集群初始化后,成员已经加入,并且集群已经到达一个值时启动actor.</p>
<p>可以通过配置文件设置一个值,来限制管理员将<code>Joining</code>状态的节点改变为<code>Up</code>时需要的最小成员数量:</p>
<pre><code>akka<span class="class">.cluster</span><span class="class">.min-nr-of-members</span> = <span class="number">3</span>
</code></pre><p>或者根据不同角色的数量来进行限制:</p>
<pre><code>akka.cluster.role {
  frontend.<span class="built_in">min</span>-nr-<span class="operator">of</span>-members = <span class="number">1</span>
  backend.<span class="built_in">min</span>-nr-<span class="operator">of</span>-members = <span class="number">2</span>
}
</code></pre><p>可以使用<code>registerOnMemberUp</code>回调来创建actor,当当前的成员状态变为<code>Up</code>时会自动被调用,集群中至少会拥和有上面定义的数量一致的成员个数:</p>
<pre><code>Cluster(<span class="keyword">system</span>) registerOnMemberUp {
  <span class="keyword">system</span>.actorOf(Props(classOf[FactorialFrontend], upToN, <span class="constant">true</span>),
    name = <span class="string">"factorialFrontend"</span>)
}
</code></pre><p>这个回调不仅仅只可以用于创建actor.</p>
<h2 id="How_To_Cleanup_when_Member_is_Removed">How To Cleanup when Member is Removed</h2><p>可以在一个<code>registerOnMemberRemoved</code>回调中处理一些清理工作,当当前的成员状态被变为<code>Removed</code>时或者集群关闭时,会自动被调用.比如在退出JVM时关闭actor系统.</p>
<pre><code>Cluster(<span class="keyword">system</span>).registerOnMemberRemoved {
 <span class="comment"> // exit JVM when ActorSystem has been terminated</span>
  <span class="keyword">system</span>.registerOnTermination(System.exit(<span class="number">0</span>))
 <span class="comment"> // shut down ActorSystem</span>
  <span class="keyword">system</span>.terminate()

 <span class="comment"> // In case ActorSystem shutdown takes longer than 10 seconds,</span>
 <span class="comment"> // exit the JVM forcefully anyway.</span>
 <span class="comment"> // We must spawn a separate thread to not block current thread,</span>
 <span class="comment"> // since that would have blocked the shutdown of the ActorSystem.</span>
  <span class="built_in">new</span> Thread {
    override def run(): Unit = {
      <span class="keyword">if</span> (Try(Await.ready(<span class="keyword">system</span>.whenTerminated, <span class="number">10.</span><span class="built_in">seconds</span>)).isFailure)
        System.exit(-<span class="number">1</span>)
    }
  }.<span class="built_in">start</span>()
}
</code></pre><h2 id="Cluster_Aware_Routers">Cluster Aware Routers</h2><p>所有种类的路由器都可以用于集群的成员,比如部署新的路由或者查找集群节点的路由.当一个节点称为<code>unreachable</code>或离开了集群,该节点的路径会自动从路由器中注销.当新节点加入集群时,一个额外的路由会根据配置添加到路由器.当节点从<code>unreachable</code>变为<code>reachable</code>状态时也会添加路由.</p>
<p>当开启<code>WeaklyUp</code>特性时,该状态的节点也会被应用路由.</p>
<p>主要有两种不同的路由:</p>
<ol>
<li>Group - router通过<code>actor selection</code>将消息发送到指定的路径.一个路由可以个集群中的不同节点共享.这类路由器的一个用例就是服务运行于集群的后台节点,路由器运行于集群的前端节点.</li>
<li>Pool - router将路由创建为子节点,并在远程节点上部署.每个路由器都会有自己的路由实例.比如,如果在一个拥有10个节点的集群中创建一个3节点的路由,如果路由器配置为每个节点一个实例的话总共会又有30个路由.被不同路由器创建的路由不会再路由器之间共享.这类路由的实例是一个单独的管理者将真正的工作路由到集群的不同节点中.</li>
</ol>
<h3 id="Router_with_Group_of_Routees">Router with Group of Routees</h3><p>当使用<code>Group</code>时必须在集群成员节点上启动路由actor.这并不是由路由器完成的,下面是配置示例:</p>
<pre><code>akka.actor.deployment {
  /statsService/workerRouter {
      router = consistent-hashing-<span class="literal">group</span>
      routees.paths = [<span class="string">"/user/statsWorker"</span>]
      <span class="keyword">cluster</span> {
        enabled = <span class="keyword">on</span>
        allow-<span class="keyword">local</span>-routees = <span class="keyword">on</span>
        <span class="keyword">use</span>-role = compute
      }
    }
}
</code></pre><p>注意,当启动actor系统时路由actor需要尽可能早的启动,因为当这些成员状态编程<code>Up</code>时路由器会立即尝试使用它们.</p>
<p>actor的路径被定义在<code>routees.paths</code>中,路由器用来选择消息将要发送的actor.消息会通过<code>ActorSelection</code>发送到路由,因此应该是符合预期的同样的传递语义.通过使用<code>use-role</code>可以限制路由对相关角色节点的查询.</p>
<p><code>max-total-nr-of-instances</code>定义了集群中路由的总数,默认设置为一个很高的值(10000),因此当节点加入到集群是路由能够加入到路由器,可以自定义进行限制.</p>
<p>同时可以在代码中进行定义:</p>
<pre><code>import akka<span class="class">.cluster</span><span class="class">.routing</span><span class="class">.ClusterRouterGroup</span>
import akka<span class="class">.cluster</span><span class="class">.routing</span><span class="class">.ClusterRouterGroupSettings</span>
import akka<span class="class">.routing</span><span class="class">.ConsistentHashingGroup</span>

val workerRouter = context.actorOf(
  <span class="function"><span class="title">ClusterRouterGroup</span><span class="params">(ConsistentHashingGroup(Nil)</span></span>, ClusterRouterGroupSettings(
    totalInstances = <span class="number">100</span>, routeesPaths = <span class="function"><span class="title">List</span><span class="params">(<span class="string">"/user/statsWorker"</span>)</span></span>,
    allowLocalRoutees = true, useRole = <span class="function"><span class="title">Some</span><span class="params">(<span class="string">"compute"</span>)</span></span>)).<span class="function"><span class="title">props</span><span class="params">()</span></span>,
  name = <span class="string">"workerRouter2"</span>)
</code></pre><h3 id="Router_Example_with_Group_of_Routees">Router Example with Group of Routees</h3><p>这个样例提供了一个文本统计的服务,当文本发送到服务时会被拆分成单词,然后将统计每个单词长度的任务分发给工作者,就是路由器的各个路由.每个单词的计数会被返回给一个聚合器,当集齐所有结果时计算每个单词的平均数.</p>
<p>消息:</p>
<pre><code><span class="keyword">final</span> <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">StatsJob</span>(<span class="title">text</span>: <span class="title">String</span>)</span>
<span class="keyword">final</span> <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">StatsResult</span>(<span class="title">meanWordLength</span>: <span class="title">Double</span>)</span>
<span class="keyword">final</span> <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">JobFailed</span>(<span class="title">reason</span>: <span class="title">String</span>)</span>
</code></pre><p>用于对每个单词计数的worker:</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">StatsWorker</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Actor</span> {</span>
  <span class="keyword">var</span> cache = <span class="type">Map</span>.empty[<span class="type">String</span>, <span class="type">Int</span>]
  <span class="function"><span class="keyword">def</span> <span class="title">receive</span> =</span> {
    <span class="keyword">case</span> word: <span class="type">String</span> =&gt;
      <span class="function"><span class="keyword">val</span> <span class="title">length</span> =</span> cache.get(word) <span class="keyword">match</span> {
        <span class="keyword">case</span> <span class="type">Some</span>(x) =&gt; x
        <span class="keyword">case</span> <span class="type">None</span> =&gt;
          <span class="function"><span class="keyword">val</span> <span class="title">x</span> =</span> word.length
          cache += (word -&gt; x)
          x
      }

      sender() ! length
  }
}
</code></pre><p>接收用户文本并拆分成单词的服务,委派worker并聚合:</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">StatsService</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Actor</span> {</span>
  <span class="comment">// This router is used both with lookup and deploy of routees. If you</span>
  <span class="comment">// have a router with only lookup of routees you can use Props.empty</span>
  <span class="comment">// instead of Props[StatsWorker.class].</span>
  <span class="function"><span class="keyword">val</span> <span class="title">workerRouter</span> =</span> context.actorOf(<span class="type">FromConfig</span>.props(<span class="type">Props</span>[<span class="type">StatsWorker</span>]),
    name = <span class="string">"workerRouter"</span>)

  <span class="function"><span class="keyword">def</span> <span class="title">receive</span> =</span> {
    <span class="keyword">case</span> <span class="type">StatsJob</span>(text) <span class="keyword">if</span> text != <span class="string">""</span> =&gt;
      <span class="function"><span class="keyword">val</span> <span class="title">words</span> =</span> text.split(<span class="string">" "</span>)
      <span class="function"><span class="keyword">val</span> <span class="title">replyTo</span> =</span> sender() <span class="comment">// important to not close over sender()</span>
      <span class="comment">// create actor that collects replies from workers</span>
      <span class="function"><span class="keyword">val</span> <span class="title">aggregator</span> =</span> context.actorOf(<span class="type">Props</span>(
        classOf[<span class="type">StatsAggregator</span>], words.size, replyTo))
      words foreach { word =&gt;
        workerRouter.tell(
          <span class="type">ConsistentHashableEnvelope</span>(word, word), aggregator)
      }
  }
}

<span class="class"><span class="keyword">class</span> <span class="title">StatsAggregator</span>(</span>expectedResults: <span class="type">Int</span>, replyTo: <span class="type">ActorRef</span>) <span class="keyword">extends</span> <span class="type">Actor</span> {
  <span class="keyword">var</span> results = <span class="type">IndexedSeq</span>.empty[<span class="type">Int</span>]
  context.setReceiveTimeout(<span class="number">3.</span>seconds)

  <span class="function"><span class="keyword">def</span> <span class="title">receive</span> =</span> {
    <span class="keyword">case</span> wordCount: <span class="type">Int</span> =&gt;
      results = results :+ wordCount
      <span class="keyword">if</span> (results.size == expectedResults) {
        <span class="function"><span class="keyword">val</span> <span class="title">meanWordLength</span> =</span> results.sum.toDouble / results.size
        replyTo ! <span class="type">StatsResult</span>(meanWordLength)
        context.stop(self)
      }
    <span class="keyword">case</span> <span class="type">ReceiveTimeout</span> =&gt;
      replyTo ! <span class="type">JobFailed</span>(<span class="string">"Service unavailable, try again later"</span>)
      context.stop(self)
  }
}
</code></pre><p>注意没有任何集群的特性,只是简单的actor.</p>
<p>所有的节点都会启动<code>StatsService</code>和<code>StatsWorker</code>actor,这个场景中worker就是路由,路由器通过<code>routees.paths</code>配置:</p>
<pre><code>akka.actor.deployment {
  /statsService/workerRouter {
    router = consistent-hashing-<span class="literal">group</span>
    routees.paths = [<span class="string">"/user/statsWorker"</span>]
    <span class="keyword">cluster</span> {
      enabled = <span class="keyword">on</span>
      allow-<span class="keyword">local</span>-routees = <span class="keyword">on</span>
      <span class="keyword">use</span>-role = compute
    }
  }
}
</code></pre><p>这表示用户的请求会被发送到任何节点的<code>StatsService</code>并会在所有节点上使用<code>StatsWorker</code>.</p>
<p>即,每个路由会在每个节点上部署,该路由会在每个节点上创建多个路由,请求会被发送到任何一个节点的路由器,然后路由器会将任务委派到任何节点上对应路由的路由.</p>
<h3 id="Router_with_Pool_of_Remote_Deployed_Routees">Router with Pool of Remote Deployed Routees</h3><p>配置示例:</p>
<pre><code>akka.actor.deployment {
  /statsService/singleton/workerRouter {
      router = consistent-hashing-pool
      cluster {
        enabled = <span class="command"><span class="keyword">on</span></span>
        <span class="built_in">max</span>-nr-<span class="operator">of</span>-instances-per-node = <span class="number">3</span>
        allow-<span class="built_in">local</span>-routees = <span class="command"><span class="keyword">on</span></span>
        use-role = compute
      }
    }
}
</code></pre><p>可以通过<code>use-role</code>指定路由部署的节点类型.</p>
<p><code>max-total-nr-of-instances</code>定义了集群中路由实例的总数.<code>max-nr-of-instances-per-node</code>定义的每个节点上的路由实例数会比总的数量要多.</p>
<p>同样可以使用代码定义配置:</p>
<pre><code>import akka<span class="class">.cluster</span><span class="class">.routing</span><span class="class">.ClusterRouterPool</span>
import akka<span class="class">.cluster</span><span class="class">.routing</span><span class="class">.ClusterRouterPoolSettings</span>
import akka<span class="class">.routing</span><span class="class">.ConsistentHashingPool</span>

val workerRouter = context.actorOf(
  <span class="function"><span class="title">ClusterRouterPool</span><span class="params">(ConsistentHashingPool(<span class="number">0</span>)</span></span>, ClusterRouterPoolSettings(
    totalInstances = <span class="number">100</span>, maxInstancesPerNode = <span class="number">3</span>,
    allowLocalRoutees = false, useRole = None)).<span class="function"><span class="title">props</span><span class="params">(Props[StatsWorker])</span></span>,
  name = <span class="string">"workerRouter3"</span>)
</code></pre><h3 id="Router_Example_with_Pool_of_Remote_Deployed_Routees">Router Example with Pool of Remote Deployed Routees</h3><p>实例中,一个单独的,master节点来创建和部署worker.使用集群单例来实现master,<code>ClusterSingletonManager</code>会在每个节点中启动:</p>
<pre><code>system.actorOf(ClusterSingletonManager.props(
  singletonProps = Props[StatsService],
  terminationMessage = PoisonPill,
  settings = <span class="function"><span class="title">ClusterSingletonManagerSettings</span><span class="params">(system)</span></span>.<span class="function"><span class="title">withRole</span><span class="params">(<span class="string">"compute"</span>)</span></span>),
  name = <span class="string">"statsService"</span>)
</code></pre><p>同时需要在每个节点上有一个actor来跟踪当前master并将任务委派给<code>StatsService</code>,通过<code>ClusterSingletonProxy</code>提供:</p>
<pre><code>system.actorOf(ClusterSingletonProxy.props(singletonManagerPath = <span class="string">"/user/statsService"</span>,
  settings = <span class="function"><span class="title">ClusterSingletonProxySettings</span><span class="params">(system)</span></span>.<span class="function"><span class="title">withRole</span><span class="params">(<span class="string">"compute"</span>)</span></span>),
  name = <span class="string">"statsServiceProxy"</span>)
</code></pre><p><code>ClusterSingletonProxy</code>会接收用户的文本并委派给当前的<code>StatsService</code>,这个单独的actor.它通过监听集群时间来在最老的节点上查找<code>StatsService</code>.</p>
<p>所有的节点都会启动<code>ClusterSingletonProxy</code>和<code>ClusterSingletonManager</code>,路由会这样配置:</p>
<pre><code>akka.actor.deployment {
  /statsService/singleton/workerRouter {
    router = consistent-hashing-pool
    cluster {
      enabled = <span class="command"><span class="keyword">on</span></span>
      <span class="built_in">max</span>-nr-<span class="operator">of</span>-instances-per-node = <span class="number">3</span>
      allow-<span class="built_in">local</span>-routees = <span class="command"><span class="keyword">on</span></span>
      use-role = compute
    }
  }
}
</code></pre><h2 id="Cluster_Singleton">Cluster Singleton</h2><p>对于有些场景或者需求,需要在集群中运行一个单独的actor.比如:</p>
<ol>
<li>一些集群中为了一致性结果的单点任务,或者集群中的协调动作</li>
<li>一个外部系统的单点入口</li>
<li>一个单独的主服务,多个工作服务</li>
<li>中央命名服务,或者路由逻辑</li>
</ol>
<p>使用单例不应该作为第一个设计选择.它有很多缺点,比如单点瓶颈,单点错误也是需要格外注意的,不过有些特性会用于处理这些问题以保证最终在其他地方会重新启动一个单例.</p>
<p>集群的单例模式通过<code>akka.cluster.singleton.ClusterSingletonManager</code>来实现.通过一个特殊的逻辑在整个集群节点或一组节点中维持一个单例actor实例.<code>ClusterSingletonManager</code>是一个可能会在所有节点上启动的actor,或者在进群中通过规则特殊指定的那些节点启动.事实上,单例actor会被<code>ClusterSingletonManager</code>在最老的节点上通过提供一个<code>Props</code>创建子actor的方式启动.<code>ClusterSingletonManager</code>会确保整个集群中在任何时间只会有一个单例运行.</p>
<p>单例actor总是会根据一个特殊的规则运行在最老的节点上.最老节点的选择通过<code>akka.cluster.Member#isOlderThan</code>类决定.这可以通过将成员移出集群来改变.注意在交接过程中会有一个很小的时间间隔没有激活的单例可用.</p>
<p>集群的错误检测器会注意到最老节点的状态改变为<code>unreachable</code>,比如JVM崩溃,硬退出或者网络错误.这是一个新的最老节点会接管并创建一个新的单例actor.对于这些错误情况并不会有一个优雅的接管方式,但是多个激活的单例actor会妨碍更多正常的任务.一些比较偏僻的问题可以通过配置超时时间来解决.</p>
<p>可以通过提供的<code>akka.cluster.singleton.ClusterSingletonProxy</code>来访问单例actor,可以将所有的消息路由到当前的单例actor实例.这个代理会保留集群中最老节点的轨迹,通过单例的<code>ActorRef</code>隐式的向单例的<code>actorSelection</code>发送<code>akka.actor.Identify</code>消息,然后等待回复.如果单例没有在一定的时间内(可配置)回复的话这个过程会被周期性的执行.如果在一个周期时间内<code>ActorRef</code>不可用则会放弃执行,比如节点已经离开集群了.这时代理会会对发送到单例的消息进行缓冲并在单例可用时进行重发.当这个缓冲满的时候又有新消息进入,<code>ClusterSingletonProxy</code>会丢弃掉最老的消息,这个缓冲可以通过配置修改并且可以设置为0来关闭缓冲.</p>
<p>由于actor的分布式性质,消息总有可能会丢失.通常会在单例中实现一些额外的逻辑或者在客户端actor中确保消息能够最少一次被提交.</p>
<h3 id="需要注意的潜在问题">需要注意的潜在问题</h3><p>这种模式看起来很能吸引人去使用,但是它也有很多缺点,下面是一个常见问题列表:</p>
<ol>
<li>集群单例可能会很快成为一个性能瓶颈</li>
<li>不能信赖集群单例永不停止的可能,当运行单例的节点宕机后需要几秒钟的时间才能转移,然后单例会被移交到另一个节点</li>
<li>在设置了<code>Automatic Downing</code>模式时可能出现的网络分割情况下,会发生每个单独的就群都会去启动一个单独的单例实例</li>
</ol>
<p>特别需要注意最后一点,在使用了集群单例模式时需要自己关注宕机的节点而不能单单依赖于<code>auto-down</code>的特性.<code>Automatic Downing</code>特性允许集群分离成多个单独的集群,这时多个集群会分别启动各自的单例.</p>
<h3 id="实例">实例</h3><p>加入我们的外部系统需要一个单点实例,一个actor接收来自<code>JMS</code>队列的消息,并且严格要求同时只能有一个<code>JMS</code>消费者存在以保证消息的处理顺序.这种事情可能没人愿意设计,但这是在于外部系统集成时一个真实的情况.</p>
<p>进群中的每个节点都需要启动一个<code>ClusterSingletonManager</code>并且提供一个单例actor的<code>Props</code>,这里是<code>JMS</code>的消费者.</p>
<pre><code>system.actorOf(ClusterSingletonManager.props(
  singletonProps = Props(classOf[Consumer], queue, testActor),
  terminationMessage = <span class="operator"><span class="keyword">End</span>,
  <span class="keyword">settings</span> = ClusterSingletonManagerSettings(<span class="keyword">system</span>).withRole(<span class="string">"worker"</span>)),
  <span class="keyword">name</span> = <span class="string">"consumer"</span>)</span>
</code></pre><p>这里限制了单例只能在<code>worker</code>角色的节点上运行,如果不指定,则可以在所有角色的节点运行.</p>
<p>这里使用了一个特殊用途的<code>terminationMessage</code>来确保在实际关闭单例之前关闭对应的资源.但如果仅需要关闭actor的话使用<code>PoisonPill</code>会比<code>terminationMessage</code>要好.</p>
<p>这里展示了单例actor如何处理<code>terminationMessage</code>消息:</p>
<pre><code><span class="keyword">case</span> End =&gt;                     <span class="comment">// 当自身收到关闭消息的时候通知队列消费者未注册</span>
  queue ! UnregisterConsumer
<span class="keyword">case</span> UnregistrationOk =&gt;        <span class="comment">// 当队列返回消息表示注销成功时才进行关闭,并设置对应的标志</span>
  stoppedBeforeUnregistration = <span class="keyword">false</span>
  context stop <span class="keyword">self</span>
<span class="keyword">case</span> Ping =&gt;
  sender() ! Pong
</code></pre><p>通过上面给出的<code>name</code>,可以使用正确配置的代理通过集群中任何一个节点访问单例.</p>
<pre><code>system.actorOf(ClusterSingletonProxy.props(
  singletonManagerPath = <span class="string">"/user/consumer"</span>,
  settings = <span class="function"><span class="title">ClusterSingletonProxySettings</span><span class="params">(system)</span></span>.<span class="function"><span class="title">withRole</span><span class="params">(<span class="string">"worker"</span>)</span></span>),
  name = <span class="string">"consumerProxy"</span>)
</code></pre><h3 id="依赖配置">依赖配置</h3><pre><code><span class="string">"com.typesafe.akka"</span> <span class="preprocessor">%</span><span class="preprocessor">%</span> <span class="string">"akka-cluster-tools"</span> <span class="preprocessor">%</span> <span class="string">"2.4.2"</span>
</code></pre><h3 id="配置选项">配置选项</h3><p>下面的配置属性,在使用<code>ActorSystem</code>参数创建单例时通过<code>ClusterSingletonManagerSettings</code>读取.<code>ClusterSingletonManagerSettings</code>是<code>ClusterSingletonManager.props</code>工厂方法的一个参数,如果需要,可以为每个单例配置不同的属性.</p>
<pre><code>akka.cluster.singleton {
  <span class="comment"># 单例actor的name.</span>
  singleton-<span class="property">name</span> = <span class="string">"singleton"</span>

  <span class="comment"># 为单例能够运行的节点指定一个角色,如果不提供角色,单例运行在所有节点上运行.</span>
  role = <span class="string">""</span>

  <span class="comment"># 当一个actor变成最老时会想上一个准备离开集群的最老的actor发送交接请求, 这个值用于设置请求的频率,</span>
  <span class="comment"># 直到该actor确认交接开始或者从集群中移除(+ akka.cluster.down-removal-margin).</span>
  hand-<span class="keyword">over</span>-retry-interval = <span class="number">1</span>s

  <span class="comment"># The number of retries are derived from hand-over-retry-interval and</span>
  <span class="comment"># akka.cluster.down-removal-margin (or ClusterSingletonManagerSettings.removalMargin),</span>
  <span class="comment"># but it will never be less than this property.</span>
  min-<span class="type">number</span>-<span class="keyword">of</span>-hand-<span class="keyword">over</span>-retries = <span class="number">10</span>
}
</code></pre><p>下面的配置属性,在使用<code>ActorSystem</code>参数创建代理时通过<code>ClusterSingletonProxySettings</code>读取.<code>ClusterSingletonProxySettings</code>是<code>ClusterSingletonProxy.props</code>工厂方法的参数,每个单例代理可以配置不同的属性.</p>
<pre><code>akka.cluster.<span class="built_in">singleton</span>-proxy {
  <span class="preprocessor"># 被ClusterSingletonManager启动的单例actor的name</span>
  <span class="built_in">singleton</span>-name = ${akka.cluster.<span class="built_in">singleton</span>.<span class="built_in">singleton</span>-name}

  <span class="preprocessor"># 单例可以部署的集群节点角色,如果不指定则所有节点都可以部署. </span>
  role = <span class="string">""</span>

  <span class="preprocessor"># 代理用来查找单例的频率</span>
  <span class="built_in">singleton</span>-identification-interval = <span class="number">1</span>s

  <span class="preprocessor"># 单例位置未知时代理缓冲消息的数量,设置为0则关闭缓冲,当单例未知则消息直接被丢弃,最大为10000. </span>
  buffer-size = <span class="number">1000</span> 
}
</code></pre><h2 id="集群中的分布式发布订阅">集群中的分布式发布订阅</h2><p>在不知道actor运行在哪个节点时如何向它发送消息呢? 或者如何向集群中订阅主题的actor进行广播消息呢?</p>
<p>该模式提供了一个中介actor,<code>akka.cluster.pubsub.DistributedPubSubMediator</code>,它会管理一个actor引用的登记薄,并复制整个集群中一个或一组通过指定规则标记的actor.</p>
<p>这个<code>DistributedPubSubMediator</code>actor允许运行在集群的所有节点,或者所有通过规则指定的节点.中介者可以通过<code>DistributedPubSub</code>扩展或者作为一个额外的actor启动.</p>
<p>登记薄是最终一致的,比如有时候改变不能作用到其他节点,但是在几秒后会被完整的复制到其他所有节点.</p>
<p>如果集群成员带有<code>WeaklyUp</code>状态,并且该特性激活,则会参与到集群的发布订阅.如果发布者节点和订阅者节点在网络分割的同一边则<code>WeaklyUp</code>状态的节点就能收到发布者的消息.</p>
<p>任何一个节点都可以通过中介者发布消息到任何其他订阅的节点.</p>
<p>消息提交有两种模式.</p>
<h3 id="Publish">Publish</h3><p>这是真正的发布/订阅模式,这个模式的典型用例就是即时通信应用中的聊天室.</p>
<p>Actor通过命名主题进行订阅.可以作用于每个节点的多个订阅者.消息会被发送到该主题的所有订阅者.</p>
<p>为了效率消息会被发送到每个节点一次(通过匹配的主题),然后提交到该节点本地代理人的所有订阅者.</p>
<p>使用<code>DistributedPubSubMediator.Subscribe</code>将actor注册到本地中介者,成功的<code>Subscribe(订阅)</code>或<code>Unsubscribe(退订)</code>通过<code>DistributedPubSubMediator.SubscribeAck</code>进行确认,通过<code>DistributedPubSubMediator.UnsubscribeAck</code>进行回复.确认的意思是该订阅已经注册,但是复制到其他节点仍然会花费一些时间.</p>
<p>通过向本地的中介者发送<code>DistributedPubSubMediator.Publish</code>消息来进行消息的发送.</p>
<p>当actor终止时会自动从订阅中移除,或者可以使用<code>DistributedPubSubMediator.Unsubscribe</code>进行显式的移除.</p>
<p>一个订阅者actor的例子:</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">Subscriber</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Actor</span> <span class="keyword"><span class="keyword">with</span></span> <span class="title">ActorLogging</span> {</span>
  <span class="keyword">import</span> <span class="type">DistributedPubSubMediator</span>.{ <span class="type">Subscribe</span>, <span class="type">SubscribeAck</span> }
  <span class="function"><span class="keyword">val</span> <span class="title">mediator</span> =</span> <span class="type">DistributedPubSub</span>(context.system).mediator     <span class="comment">// 获取本地中介者引用</span>
  mediator ! <span class="type">Subscribe</span>(<span class="string">"content"</span>, self)                         <span class="comment">// 订阅"content"主题</span>

  <span class="function"><span class="keyword">def</span> <span class="title">receive</span> =</span> {
    <span class="keyword">case</span> s: <span class="type">String</span> =&gt; log.info(<span class="string">"Got {}"</span>, s)
    <span class="keyword">case</span> <span class="type">SubscribeAck</span>(<span class="type">Subscribe</span>(<span class="string">"content"</span>, <span class="type">None</span>, `self`)) =&gt; log.info(<span class="string">"subscribing"</span>);
  }
}
</code></pre><p>订阅者actor可以在集群中的多个节点启动,都会受到发布到<code>content</code>主题的消息:</p>
<pre><code><span class="function"><span class="title">runOn</span><span class="params">(first)</span> {
  <span class="title">system</span>.<span class="title">actorOf</span><span class="params">(<span class="variable">Props</span>[<span class="variable">Subscriber</span>], <span class="string">"subscriber1"</span>)</span>
}
<span class="title">runOn</span><span class="params">(second)</span> {
  <span class="title">system</span>.<span class="title">actorOf</span><span class="params">(<span class="variable">Props</span>[<span class="variable">Subscriber</span>], <span class="string">"subscriber2"</span>)</span>
  <span class="title">system</span>.<span class="title">actorOf</span><span class="params">(<span class="variable">Props</span>[<span class="variable">Subscriber</span>], <span class="string">"subscriber3"</span>)</span>
}</span>
</code></pre><p>主题<code>content</code>的发布者actor例子:</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">Publisher</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Actor</span> {</span>
  <span class="keyword">import</span> <span class="type">DistributedPubSubMediator</span>.<span class="type">Publish</span>
  <span class="comment">// activate the extension</span>
  <span class="function"><span class="keyword">val</span> <span class="title">mediator</span> =</span> <span class="type">DistributedPubSub</span>(context.system).mediator

  <span class="function"><span class="keyword">def</span> <span class="title">receive</span> =</span> {
    <span class="keyword">case</span> in: <span class="type">String</span> =&gt;
      <span class="function"><span class="keyword">val</span> <span class="title">out</span> =</span> in.toUpperCase
      mediator ! <span class="type">Publish</span>(<span class="string">"content"</span>, out)
  }
}
</code></pre><p>可以从集群中的任何节点想主题发布消息:</p>
<pre><code>runOn(third) {
  <span class="variable"><span class="keyword">val</span> publisher</span> = system.actorOf(Props[Publisher], <span class="string">"publisher"</span>)
  later()
  <span class="comment">// after a while the subscriptions are replicated</span>
  publisher ! <span class="string">"hello"</span>
}
</code></pre><p>Actor同时可以使用一个可选的属性(group)对命名主题进行订阅.如果通过组名(group name)订阅,任何发布到主题中并且标记为<code>sendOneMessageToEachGroup</code>的消息会通过提供的<code>RoutingLogic</code>(默认为random)会被发送到该订阅组中的其中一个actor,如果所有的订阅者都拥有相同的组名,这是工作方式就类似于<code>Send</code>并且所有的消息都会被提交给一个actor.同样,如果每个actor都拥有不同的组名,则工作方式就跟普通的<code>Publish</code>一样,所有的消息都会被广播的所有的订阅者.</p>
<h3 id="Send">Send</h3><p>这是一个点对点(point-to-point)的模式,每个消息都被提交到一个目的地,但是同样不需要知道目的地的位置.这个模式的经典用例是及时通信应用中的用户私聊.同样可以用于分布任务到已注册的工作者,类似一个集群路由器并且路由可以对自己进行动态注册.</p>
<p>如果没有任何注册的话,消息会通过一个路径匹配提交到授权者.如果由于已经在多个节点上注册从何多个实体匹配到了这个路径,则消息会通过提供的<code>RoutingLogic</code>(默认Random)提交到其中一个目的地.消息的<code>sender()</code>可以指定本地关系优先.如果可能的话,消息会被发送到本地的同一个actor系统中,就像之前用过的中介者,否则会路由到其他匹配的实体.</p>
<p>通过<code>DistributedPubSubMediator.Put</code>将actor注册到本地中介者.<code>Put</code>方法中的<code>ActorRef</code>必须和中介者在同一个本地的actor系统.不带地址信息的路径是用来发送消息的键(key).一个节点中只能存在一个这个路径的actor,因为同一个本地actor系统中路径是唯一的.</p>
<p>通过向本地中介者发送带有目的actor路径(不带地址信息)的<code>DistributedPubSubMediator.Send</code>消息来进行消息的发送.</p>
<p>Actor终止时会自动从订阅中移除,或者通过<code>DistributedPubSubMediator.Remove</code>显式的移除.</p>
<p>一个目的地actor的例子:</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">Destination</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Actor</span> <span class="keyword"><span class="keyword">with</span></span> <span class="title">ActorLogging</span> {</span>
  <span class="keyword">import</span> <span class="type">DistributedPubSubMediator</span>.<span class="type">Put</span>
  <span class="function"><span class="keyword">val</span> <span class="title">mediator</span> =</span> <span class="type">DistributedPubSub</span>(context.system).mediator

  mediator ! <span class="type">Put</span>(self)      <span class="comment">// 通过本地中介者注册自己的路径</span>

  <span class="function"><span class="keyword">def</span> <span class="title">receive</span> =</span> {
    <span class="keyword">case</span> s: <span class="type">String</span> =&gt; log.info(<span class="string">"Got {}"</span>, s)
  }
}
</code></pre><p>目的地actor可以在集群中的多个节点启动,都会受到发送到该路径的消息:</p>
<pre><code><span class="function"><span class="title">runOn</span><span class="params">(first)</span> {
  <span class="title">system</span>.<span class="title">actorOf</span><span class="params">(<span class="variable">Props</span>[<span class="variable">Destination</span>], <span class="string">"destination"</span>)</span>
}
<span class="title">runOn</span><span class="params">(second)</span> {
  <span class="title">system</span>.<span class="title">actorOf</span><span class="params">(<span class="variable">Props</span>[<span class="variable">Destination</span>], <span class="string">"destination"</span>)</span>
}</span>
</code></pre><p>向该路径发送消息的actor例子:</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">Sender</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Actor</span> {</span>
  <span class="keyword">import</span> <span class="type">DistributedPubSubMediator</span>.<span class="type">Send</span>
  <span class="comment">// activate the extension</span>
  <span class="function"><span class="keyword">val</span> <span class="title">mediator</span> =</span> <span class="type">DistributedPubSub</span>(context.system).mediator

  <span class="function"><span class="keyword">def</span> <span class="title">receive</span> =</span> {
    <span class="keyword">case</span> in: <span class="type">String</span> =&gt;
      <span class="function"><span class="keyword">val</span> <span class="title">out</span> =</span> in.toUpperCase
      mediator ! <span class="type">Send</span>(path = <span class="string">"/user/destination"</span>, msg = out, localAffinity = <span class="literal">true</span>)
  }
}
</code></pre><p>可以从集群的任何节点发送消息:</p>
<pre><code>runOn(third) {
  <span class="variable"><span class="keyword">val</span> sender</span> = system.actorOf(Props[Sender], <span class="string">"sender"</span>)
  later()
  <span class="comment">// after a while the destinations are replicated</span>
  sender ! <span class="string">"hello"</span>
}
</code></pre><p>同时可以通过向本地中介者发送<code>Put.SendDistributedPubSubMediator.SendToAll</code>消息,将消息发送到所有注册到匹配路径的目的地actor.带有相同路径不带地址信息的actor可以注册到不同的节点,每个节点上只能存在一个这样的节点,因为本地actor系统中路径是唯一的.</p>
<p>这个模式的经典用例是讲消息广播到所有拥有相同路径的actor.比如不同的节点都执行相同的动作.同时可以指定一个特殊的属性(allButSelf)来决定是否将消息发送到自身节点中匹配的路径.</p>
<h3 id="DistributedPubSub_Extension">DistributedPubSub Extension</h3><p>上面的例子中,中介者使用<code>akka.cluster.pubsub.DistributedPubSub</code>扩展来创建和访问.在很多场景中这是方便理想的方式,同时需要了解的是可以创建一个单独的actor来作为中介者,或者同时创建多个不同的中介者来大量的actor或主题分割到不同的中介者.比如可以为不同的中介者使用不同的集群节点角色.</p>
<p><code>DistributedPubSub</code>扩展可以通过下面的配置文件来设置属性:</p>
<pre><code><span class="comment"># Settings for the DistributedPubSub extension</span>
akka.cluster.pub-<span class="sub"><span class="keyword">sub</span> {</span>
  <span class="comment"># 中介者的actor名字name, /system/distributedPubSubMediator</span>
  name = distributedPubSubMediator

  <span class="comment"># 在那种角色的节点上穿件这个中介者actor,不设置则在所有节点创建</span>
  role = <span class="string">""</span>

  <span class="comment"># `Send`的路由方法: random, round-robin, broadcast</span>
  routing-logic = random

  <span class="comment"># DistributedPubSubMediator发送gossip信息的频率</span>
  gossip-interval = <span class="number">1</span><span class="keyword">s</span>

  <span class="comment"># Removed entries are pruned after this duration</span>
  removed-<span class="keyword">time</span>-to-live = <span class="number">120</span><span class="keyword">s</span>

  <span class="comment"># Maximum number of elements to transfer in one message when synchronizing the registries.</span>
  <span class="comment"># Next chunk will be transferred in next round of gossip.</span>
  max-delta-elements = <span class="number">3000</span>

  <span class="comment"># The id of the dispatcher to use for DistributedPubSubMediator actors. </span>
  <span class="comment"># If not specified default dispatcher is used.</span>
  <span class="comment"># If specified you need to define the settings of the actual dispatcher.</span>
  <span class="keyword">use</span>-dispatcher = <span class="string">""</span>
}
</code></pre><p>推荐的做法是通过定义<code>akka.extensions</code>属性以在actor系统启动是加载扩展.否则会在第一次启动时加载,这通常会需要一点时间.</p>
<pre><code>akka<span class="class">.extensions</span> = [<span class="string">"akka.cluster.pubsub.DistributedPubSub"</span>]
</code></pre><h3 id="依赖">依赖</h3><pre><code><span class="string">"com.typesafe.akka"</span> <span class="preprocessor">%</span><span class="preprocessor">%</span> <span class="string">"akka-cluster-tools"</span> <span class="preprocessor">%</span> <span class="string">"2.4.2"</span>
</code></pre><h2 id="Cluster_Client">Cluster Client</h2><p>集群之外的actor系统可以通过<code>ClusterClient</code>与集群进行通信,这个客户端可以属于另外一个集群.它只需要知道一个或其中几个节点作为最初的联系点.它会创建一个与集群中<code>ClusterReceptionist</code>的连接,并且监控连接,如果连接丢失则会重新进行创建.当寻找新的连接点时会刷新上一个连接,或者周期性的刷新连接,最初的连接点并不是必须的.</p>
<p>注意: <code>ClusterClient</code>不能用于向运行于集群本身的actor发送消息.如果需要,可以使用分布式的订阅发布来向当前集群的actor发送消息.</p>
<p>注意在使用<code>ClusterClient</code>时同样需要将Akka的<code>akka.actor.provider</code>从<code>akka.actor.LocalActorRefProvider</code>改变为<code>akka.remote.RemoteActorRefProvider or akka.cluster.ClusterActorRefProvider</code>.</p>
<p>连接点可以在所有节点上启动,或者通过指定一个规则在部分节点上启动.通过<code>ClusterClientReceptionist</code>扩展启动,或者作为一个单独的actor启动.</p>
<p>可以通过<code>ClusterClient</code>向集群中使用<code>ClusterReceptionist</code>注册到<code>DistributedPubSubMediator</code>的actor发送消息.<code>ClusterClientReceptionist</code>为已注册的actor提供了一个方法用于和客户端联系.消息通过<code>ClusterClient.Send</code>,<code>ClusterClient.SendToAll</code>或<code>ClusterClient.Publish</code>封装.</p>
<ol>
<li><p><code>ClusterClient.Send</code>: 消息会通过匹配的路径提交给一个存在的接收者,如果同时有多个匹配路径的实体会通过随机的方式提交到目的地.消息的<code>sender()</code>可以指定本地优先.</p>
</li>
<li><p><code>ClusterClient.SendToAll</code>: 消息会被发送到所有匹配路径的目的地.</p>
</li>
<li><p><code>ClusterClient.Publish</code>: 消息会被发送到所有通过主题名注册为订阅者的目的地.</p>
</li>
</ol>
<p>从目的地actor回复的消息会被接待者以隧道的方式转接,以避免其他集群的节点对连接的绑定.比如,被目的地actor看到的<code>sender()</code>并不是这个客户端本身.被客户端看到的发送响应消息的<code>sneder()</code>会收到<code>deadLetters</code>,因为客户端通常会通过<code>ClusterClient</code>发送后续的消息.如果客户端需要立即与集群中的一个actor通信时,同样可以在回复消息中传入原始的sender.</p>
<p>当与目的地之间建立联系时,<code>ClusterClient</code>会对消息进行缓冲然后当连接建立完成后将消息发送.缓冲满的时候<code>ClusterClient</code>再收到新的消息则会将最老的消息丢弃.或者将缓冲设置为0来关闭缓冲功能.</p>
<h3 id="实例-1">实例</h3><p>首先在集群中启动接待员.推荐的做法是通过在配置文件中定义<code>akka.extensions</code>属性在actor系统启动时加载扩展.</p>
<pre><code>akka<span class="class">.extensions</span> = [<span class="string">"akka.cluster.client.ClusterClientReceptionist"</span>]
</code></pre><p>然后将客户端需要连接的actor进行注册:</p>
<pre><code><span class="function"><span class="title">runOn</span><span class="params">(host1)</span> {
  <span class="title">val</span> <span class="title">serviceA</span> = <span class="title">system</span>.<span class="title">actorOf</span><span class="params">(<span class="variable">Props</span>[<span class="variable">Service</span>], <span class="string">"serviceA"</span>)</span>
  C<span class="title">lusterClientReceptionist</span><span class="params">(system)</span>.<span class="title">registerService</span><span class="params">(service<span class="variable">A</span>)</span>
}

<span class="title">runOn</span><span class="params">(host2, host3)</span> {
  <span class="title">val</span> <span class="title">serviceB</span> = <span class="title">system</span>.<span class="title">actorOf</span><span class="params">(<span class="variable">Props</span>[<span class="variable">Service</span>], <span class="string">"serviceB"</span>)</span>
  C<span class="title">lusterClientReceptionist</span><span class="params">(system)</span>.<span class="title">registerService</span><span class="params">(service<span class="variable">B</span>)</span>
}</span>
</code></pre><p>在客户端可以创建一个<code>ClusterClient</code>actor作为网关来向集群中被路径标识的actor发送消息.</p>
<pre><code>runOn(client) {
  val <span class="built_in">c</span> = system.actorOf(<span class="type">ClusterClient</span>.props(
    <span class="type">ClusterClientSettings</span>(system).withInitialContacts(initialContacts)), <span class="string">"client"</span>)
  <span class="built_in">c</span> ! <span class="type">ClusterClient</span>.<span class="type">Send</span>(<span class="string">"/user/serviceA"</span>, <span class="string">"hello"</span>, localAffinity = <span class="literal">true</span>)
  <span class="built_in">c</span> ! <span class="type">ClusterClient</span>.<span class="type">SendToAll</span>(<span class="string">"/user/serviceB"</span>, <span class="string">"hi"</span>)
}
</code></pre><p>上面的<code>initialContacts</code>参数是一个<code>Set[ActorPath]</code>,可以按如下的方式创建:</p>
<pre><code>val initialContacts = Set(
  ActorPath.<span class="function"><span class="title">fromString</span><span class="params">(<span class="string">"akka.tcp://OtherSys@host1:2552/system/receptionist"</span>)</span></span>,
  ActorPath.<span class="function"><span class="title">fromString</span><span class="params">(<span class="string">"akka.tcp://OtherSys@host2:2552/system/receptionist"</span>)</span></span>)
val settings = <span class="function"><span class="title">ClusterClientSettings</span><span class="params">(system)</span></span>
  .<span class="function"><span class="title">withInitialContacts</span><span class="params">(initialContacts)</span></span>
</code></pre><p>或者在配置文件中或系统变量中定义.</p>
<h3 id="ClusterClientReceptionist_Extension">ClusterClientReceptionist Extension</h3><p>上面的例子中接待者使用<code>akka.cluster.client.ClusterClientReceptionist</code>扩展创建和访问.这种方式很方便,通知支持启动一个单独的<code>akka.cluster.client.ClusterReceptionist</code>actor,并且支持同时存在多个接待者以服务不同类型的客户端.</p>
<p>注意<code>ClusterClientReceptionist</code>同时使用了<code>DistributedPubSub</code>扩展,已经在分布式发布订阅集群的部分进行了介绍.</p>
<h3 id="依赖-1">依赖</h3><pre><code><span class="string">"com.typesafe.akka"</span> <span class="preprocessor">%</span><span class="preprocessor">%</span> <span class="string">"akka-cluster-tools"</span> <span class="preprocessor">%</span> <span class="string">"2.4.2"</span>
</code></pre><h3 id="配置">配置</h3><p><code>ClusterClientReceptionist</code>扩展可以通过如下属性进行配置:</p>
<pre><code><span class="comment"># Settings for the ClusterClientReceptionist extension</span>
akka.cluster.client.receptionist {
  <span class="comment"># Actor name of the ClusterReceptionist actor, /system/receptionist</span>
  <span class="property">name</span> = receptionist

  <span class="comment"># 用以启动接待者的节点角色,不设置则所有节点都可以启动</span>
  role = <span class="string">""</span>

  <span class="comment"># The receptionist will send this number of contact points to the client</span>
  <span class="type">number</span>-<span class="keyword">of</span>-contacts = <span class="number">3</span>

  <span class="comment"># The actor that tunnel response messages to the client will be stopped</span>
  <span class="comment"># after this time of inactivity.</span>
  response-tunnel-receive-<span class="keyword">timeout</span> = <span class="number">30</span>s

  <span class="comment"># The id of the dispatcher to use for ClusterReceptionist actors. </span>
  <span class="comment"># If not specified default dispatcher is used.</span>
  <span class="comment"># If specified you need to define the settings of the actual dispatcher.</span>
  use-dispatcher = <span class="string">""</span>

}
</code></pre><p>下面的配置属性在使用参数创建<code>ActorSystem</code>时由<code>ClusterClientSettings</code>读取,或者可以通过<code>ClusterClientSettings</code>在读取时按上面的格式设置其他的配置文件.</p>
<pre><code><span class="comment"># Settings for the ClusterClient</span>
akka.cluster.client {
  <span class="comment"># Actor paths of the ClusterReceptionist actors on the servers (cluster nodes)</span>
  <span class="comment"># that the client will try to contact initially. It is mandatory to specify</span>
  <span class="comment"># at least one initial contact. </span>
  <span class="comment"># Comma separated full actor paths defined by a string on the form of</span>
  <span class="comment"># "akka.tcp://system@hostname:port/system/receptionist"</span>
  initial-contacts = []

  <span class="comment"># Interval at which the client retries to establish contact with one of </span>
  <span class="comment"># ClusterReceptionist on the servers (cluster nodes)</span>
  establishing-<span class="keyword">get</span>-contacts-interval = <span class="number">3</span>s

  <span class="comment"># Interval at which the client will ask the ClusterReceptionist for</span>
  <span class="comment"># new contact points to be used for next reconnect.</span>
  refresh-contacts-interval = <span class="number">60</span>s

  <span class="comment"># How often failure detection heartbeat messages should be sent</span>
  heartbeat-interval = <span class="number">2</span>s

  <span class="comment"># Number of potentially lost/delayed heartbeats that will be</span>
  <span class="comment"># accepted before considering it to be an anomaly.</span>
  <span class="comment"># The ClusterClient is using the akka.remote.DeadlineFailureDetector, which</span>
  <span class="comment"># will trigger if there are no heartbeats within the duration </span>
  <span class="comment"># heartbeat-interval + acceptable-heartbeat-pause, i.e. 15 seconds with</span>
  <span class="comment"># the default settings.</span>
  acceptable-heartbeat-pause = <span class="number">13</span>s

  <span class="comment"># If connection to the receptionist is not established the client will buffer</span>
  <span class="comment"># this number of messages and deliver them the connection is established.</span>
  <span class="comment"># When the buffer is full old messages will be dropped when new messages are sent</span>
  <span class="comment"># via the client. Use 0 to disable buffering, i.e. messages will be dropped</span>
  <span class="comment"># immediately if the location of the singleton is unknown.</span>
  <span class="comment"># Maximum allowed buffer size is 10000.</span>
  buffer-size = <span class="number">1000</span>

  <span class="comment"># If connection to the receiptionist is lost and the client has not been</span>
  <span class="comment"># able to acquire a new connection for this long the client will stop itself.</span>
  <span class="comment"># This duration makes it possible to watch the cluster client and react on a more permanent</span>
  <span class="comment"># loss of connection with the cluster, for example by accessing some kind of</span>
  <span class="comment"># service registry for an updated set of initial contacts to start a new cluster client with.</span>
  <span class="comment"># If this is not wanted it can be set to "off" to disable the timeout and retry</span>
  <span class="comment"># forever.</span>
  reconnect-<span class="keyword">timeout</span> = off
}
</code></pre></span>
      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Akka/" rel="tag">#Akka</a>
          
            <a href="/tags/Scala/" rel="tag">#Scala</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/04/03/Simple-SBT-Getting-start/" rel="prev">Simple SBT: Getting start</a>
            
          </div>

          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/03/27/Simple-Akka-Persistence/" rel="next">Simple Akka: Persistence</a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

 </div>

        

        
          <div class="comments" id="comments">
            
          </div>
        
      </div>

      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="http://7xiwca.com1.z0.glb.clouddn.com/headpicture.gif" alt="Zhange" itemprop="image"/>
          <p class="site-author-name" itemprop="name">Zhange</p>
        </div>
        <p class="site-description motion-element" itemprop="description">Zhange's notes</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">114</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            
              <span class="site-state-item-count">0</span>
              <span class="site-state-item-name">分类</span>
              
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">40</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      
        <section class="post-toc-wrap sidebar-panel-active">
          <div class="post-toc-indicator-top post-toc-indicator"></div>
          <div class="post-toc">
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#简介"><span class="nav-number">1.</span> <span class="nav-text">简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Gossip协议"><span class="nav-number">1.1.</span> <span class="nav-text">Gossip协议</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#术语"><span class="nav-number">2.</span> <span class="nav-text">术语</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#成员关系"><span class="nav-number">3.</span> <span class="nav-text">成员关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Gossip"><span class="nav-number">4.</span> <span class="nav-text">Gossip</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#向量时钟(Vector_Clocks)"><span class="nav-number">5.</span> <span class="nav-text">向量时钟(Vector Clocks)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Gossip_Convergence"><span class="nav-number">6.</span> <span class="nav-text">Gossip Convergence</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Failure_Detector"><span class="nav-number">7.</span> <span class="nav-text">Failure Detector</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Leader"><span class="nav-number">8.</span> <span class="nav-text">Leader</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Seed_Nodes"><span class="nav-number">9.</span> <span class="nav-text">Seed Nodes</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Gossip_Protocol"><span class="nav-number">10.</span> <span class="nav-text">Gossip Protocol</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Membership_Lifecycle"><span class="nav-number">11.</span> <span class="nav-text">Membership Lifecycle</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#成员状态"><span class="nav-number">11.1.</span> <span class="nav-text">成员状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用户动作"><span class="nav-number">11.2.</span> <span class="nav-text">用户动作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Leader动作"><span class="nav-number">11.3.</span> <span class="nav-text">Leader动作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#添加依赖"><span class="nav-number">12.</span> <span class="nav-text">添加依赖</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#一个简单的集群例子"><span class="nav-number">13.</span> <span class="nav-text">一个简单的集群例子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#向集群中添加一个节点"><span class="nav-number">14.</span> <span class="nav-text">向集群中添加一个节点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自动或手动关闭"><span class="nav-number">15.</span> <span class="nav-text">自动或手动关闭</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Leaving"><span class="nav-number">16.</span> <span class="nav-text">Leaving</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#WeaklyUp_Members(实验性,仅支持2-4以上的版本)"><span class="nav-number">17.</span> <span class="nav-text">WeaklyUp Members(实验性,仅支持2.4以上的版本)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#订阅集群事件"><span class="nav-number">18.</span> <span class="nav-text">订阅集群事件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Worker_Dial-in_Example"><span class="nav-number">19.</span> <span class="nav-text">Worker Dial-in Example</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#节点角色"><span class="nav-number">20.</span> <span class="nav-text">节点角色</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#How_To_Startup_when_Cluster_Size_Reached"><span class="nav-number">21.</span> <span class="nav-text">How To Startup when Cluster Size Reached</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#How_To_Cleanup_when_Member_is_Removed"><span class="nav-number">22.</span> <span class="nav-text">How To Cleanup when Member is Removed</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Cluster_Aware_Routers"><span class="nav-number">23.</span> <span class="nav-text">Cluster Aware Routers</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Router_with_Group_of_Routees"><span class="nav-number">23.1.</span> <span class="nav-text">Router with Group of Routees</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Router_Example_with_Group_of_Routees"><span class="nav-number">23.2.</span> <span class="nav-text">Router Example with Group of Routees</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Router_with_Pool_of_Remote_Deployed_Routees"><span class="nav-number">23.3.</span> <span class="nav-text">Router with Pool of Remote Deployed Routees</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Router_Example_with_Pool_of_Remote_Deployed_Routees"><span class="nav-number">23.4.</span> <span class="nav-text">Router Example with Pool of Remote Deployed Routees</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Cluster_Singleton"><span class="nav-number">24.</span> <span class="nav-text">Cluster Singleton</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#需要注意的潜在问题"><span class="nav-number">24.1.</span> <span class="nav-text">需要注意的潜在问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实例"><span class="nav-number">24.2.</span> <span class="nav-text">实例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#依赖配置"><span class="nav-number">24.3.</span> <span class="nav-text">依赖配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#配置选项"><span class="nav-number">24.4.</span> <span class="nav-text">配置选项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#集群中的分布式发布订阅"><span class="nav-number">25.</span> <span class="nav-text">集群中的分布式发布订阅</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Publish"><span class="nav-number">25.1.</span> <span class="nav-text">Publish</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Send"><span class="nav-number">25.2.</span> <span class="nav-text">Send</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DistributedPubSub_Extension"><span class="nav-number">25.3.</span> <span class="nav-text">DistributedPubSub Extension</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#依赖"><span class="nav-number">25.4.</span> <span class="nav-text">依赖</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Cluster_Client"><span class="nav-number">26.</span> <span class="nav-text">Cluster Client</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#实例-1"><span class="nav-number">26.1.</span> <span class="nav-text">实例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ClusterClientReceptionist_Extension"><span class="nav-number">26.2.</span> <span class="nav-text">ClusterClientReceptionist Extension</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#依赖-1"><span class="nav-number">26.3.</span> <span class="nav-text">依赖</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#配置"><span class="nav-number">26.4.</span> <span class="nav-text">配置</span></a></li></ol></li></ol></div>
            
          </div>
          <div class="post-toc-indicator-bottom post-toc-indicator"></div>
        </section>
      

    </div>
  </aside>


    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner"> <div class="copyright" >
  
  &copy; &nbsp; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="icon-next-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhange</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


 </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  
  
    
    

  


  
  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.1"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.1"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.5.1" id="motion.global"></script>




  <script type="text/javascript" src="/js/nav-toggle.js?v=0.4.5.1"></script>
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  
<script type="text/javascript" src="/js/bootstrap.scrollspy.js?v=0.4.5.1" id="bootstrap.scrollspy.custom"></script>


<script type="text/javascript" id="sidebar.toc.highlight">
  $(document).ready(function () {
    var tocSelector = '.post-toc';
    var $tocSelector = $(tocSelector);
    var activeCurrentSelector = '.active-current';

    $tocSelector
      .on('activate.bs.scrollspy', function () {
        var $currentActiveElement = $(tocSelector + ' .active').last();

        removeCurrentActiveClass();
        $currentActiveElement.addClass('active-current');

        $tocSelector[0].scrollTop = $currentActiveElement.position().top;
      })
      .on('clear.bs.scrollspy', function () {
        removeCurrentActiveClass();
      });

    function removeCurrentActiveClass () {
      $(tocSelector + ' ' + activeCurrentSelector)
        .removeClass(activeCurrentSelector.substring(1));
    }

    function processTOC () {
      getTOCMaxHeight();
      toggleTOCOverflowIndicators();
    }

    function getTOCMaxHeight () {
      var height = $('.sidebar').height() -
                   $tocSelector.position().top -
                   $('.post-toc-indicator-bottom').height();

      $tocSelector.css('height', height);

      return height;
    }

    function toggleTOCOverflowIndicators () {
      tocOverflowIndicator(
        '.post-toc-indicator-top',
        $tocSelector.scrollTop() > 0 ? 'show' : 'hide'
      );

      tocOverflowIndicator(
        '.post-toc-indicator-bottom',
        $tocSelector.scrollTop() >= $tocSelector.find('ol').height() - $tocSelector.height() ? 'hide' : 'show'
      )
    }

    $(document).on('sidebar.motion.complete', function () {
      processTOC();
    });

    $('body').scrollspy({ target: tocSelector });
    $(window).on('resize', function () {
      if ( $('.sidebar').hasClass('sidebar-active') ) {
        processTOC();
      }
    });

    onScroll($tocSelector);

    function onScroll (element) {
      element.on('mousewheel DOMMouseScroll', function (event) {
          var oe = event.originalEvent;
          var delta = oe.wheelDelta || -oe.detail;

          this.scrollTop += ( delta < 0 ? 1 : -1 ) * 30;
          event.preventDefault();

          toggleTOCOverflowIndicators();
      });
    }

    function tocOverflowIndicator (indicator, action) {
      var $indicator = $(indicator);
      var opacity = action === 'show' ? 0.4 : 0;
      $indicator.velocity ?
        $indicator.velocity('stop').velocity({
          opacity: opacity
        }, { duration: 100 }) :
        $indicator.stop().animate({
          opacity: opacity
        }, 100);
    }

  });
</script>

<script type="text/javascript" id="sidebar.nav">
  $(document).ready(function () {
    var html = $('html');
    var TAB_ANIMATE_DURATION = 200;
    var hasVelocity = $.isFunction(html.velocity);

    $('.sidebar-nav li').on('click', function () {
      var item = $(this);
      var activeTabClassName = 'sidebar-nav-active';
      var activePanelClassName = 'sidebar-panel-active';
      if (item.hasClass(activeTabClassName)) {
        return;
      }

      var currentTarget = $('.' + activePanelClassName);
      var target = $('.' + item.data('target'));

      hasVelocity ?
        currentTarget.velocity('transition.slideUpOut', TAB_ANIMATE_DURATION, function () {
          target
            .velocity('stop')
            .velocity('transition.slideDownIn', TAB_ANIMATE_DURATION)
            .addClass(activePanelClassName);
        }) :
        currentTarget.animate({ opacity: 0 }, TAB_ANIMATE_DURATION, function () {
          currentTarget.hide();
          target
            .stop()
            .css({'opacity': 0, 'display': 'block'})
            .animate({ opacity: 1 }, TAB_ANIMATE_DURATION, function () {
              currentTarget.removeClass(activePanelClassName);
              target.addClass(activePanelClassName);
            });
        });

      item.siblings().removeClass(activeTabClassName);
      item.addClass(activeTabClassName);
    });

    $('.post-toc a').on('click', function (e) {
      e.preventDefault();
      var targetSelector = escapeSelector(this.getAttribute('href'));
      var offset = $(targetSelector).offset().top;
      hasVelocity ?
        html.velocity('stop').velocity('scroll', {
          offset: offset  + 'px',
          mobileHA: false
        }) :
        $('html, body').stop().animate({
          scrollTop: offset
        }, 500);
    });

    // Expand sidebar on post detail page by default, when post has a toc.
    var $tocContent = $('.post-toc-content');
    if (isDesktop() && CONFIG.sidebar === 'post') {
      if ($tocContent.length > 0 && $tocContent.html().trim().length > 0) {
        displaySidebar();
      }
    }
  });
</script>



  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
      if (isMobile()) {
        FastClick.attach(document.body);
      }
    });
  </script>

  

  
  

  
  <script type="text/javascript" src="/js/lazyload.js"></script>
  <script type="text/javascript">
    $(function () {
      $("#posts").find('img').lazyload({
        placeholder: "/images/loading.gif",
        effect: "fadeIn"
      });
    });
  </script>
</body>
</html>
