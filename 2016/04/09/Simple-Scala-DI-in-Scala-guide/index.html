<!doctype html>
<html class="theme-next use-motion theme-next-mist">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />








  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>




<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.5.1"/>


    <meta name="description" content="Zhange's notes" />



  <meta name="keywords" content="Scala," />





  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.1" />


<meta name="description" content="Scala中的依赖注入.">
<meta property="og:type" content="article">
<meta property="og:title" content="Simple Scala: DI in Scala: guide">
<meta property="og:url" content="http://yoursite.com/2016/04/09/Simple-Scala-DI-in-Scala-guide/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Scala中的依赖注入.">
<meta property="og:updated_time" content="2016-04-14T15:50:21.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Simple Scala: DI in Scala: guide">
<meta name="twitter:description" content="Scala中的依赖注入.">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: 'Mist',
    sidebar: 'post'
  };
</script>

  <title> Simple Scala: DI in Scala: guide | Hexo </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  



  <div class="container one-column page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand" rel="start">
      <span class="logo">
        <i class="icon-next-logo"></i>
      </span>
      <span class="site-title">Zhange's notes</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon icon-next-home"></i> <br />
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            <i class="menu-item-icon icon-next-archives"></i> <br />
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            <i class="menu-item-icon icon-next-tags"></i> <br />
            标签
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content"> 

  <div id="posts" class="posts-expand">
    

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              Simple Scala: DI in Scala: guide
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2016-04-09T21:03:47+08:00" content="2016-04-09">
            2016-04-09
          </time>
        </span>

        

        
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        <span itemprop="articleBody"><h2 id="介绍">介绍</h2><p>DI是一个流行的模式,用于降低客户端与服务端实现间的耦合.本文将介绍如何使用Scala语言来构建依赖注入,然后剩下的一些实践将会借助<code>MacWire</code>库进行.</p>
<p>DI是一个简单的概念,可以通过几种简单的方式实现.我们应该避免不对代价进行分析就使用过于复杂或难于使用的容器或框架.</p>
<h2 id="什么是依赖注入">什么是依赖注入</h2><p>DI主要是为了解耦客户端和服务端代码(这里的客户端可以是另一个服务端).服务端需要显示他们需要的依赖信息.不在服务内部创建一个依赖服务,而是通过”引用”依赖服务的方式,称为”注入”.这使代码更易于理解,测试和重用.</p>
<p>注入依赖的方式多种多样,这里我们将通过构造器参数传入依赖.其他的方式有<code>setter/field</code>方式的注入,或者使用一个服务定位.因此,DI的本质可以总结为使用构造器参数.</p>
<p>DI一个重要的方面是控制反转,服务实现需要在服务外部创建,比如一个容器或者一些外部连接代码.而在服务中直接使用<code>new</code>来创建依赖是不允许的.</p>
<p>如果对DI不熟悉,可以首先了解一下<a href="https://github.com/google/guice/wiki/Motivation" title="guice" target="_blank" rel="external">guice</a>.基于Java语言,想法都是一致的,并且应用广泛.</p>
<h2 id="其他方式">其他方式</h2><p>有很多框架和方法通过不同的语言和平台实现DI,下面是一些使用<code>Scala+Macwire</code>实现的方法.</p>
<p>框架:</p>
<ol>
<li>Subcut: 混合服务定位和依赖注入的模式</li>
<li>Scaldi: 与Subcut类似</li>
<li>Spring: 是一个流行的Java DI框架,同样可以用于Scala</li>
<li>Guice: 另一个流行的Java DI框架</li>
</ol>
<p>使用纯Scala:</p>
<ol>
<li>Cake pattern</li>
<li>Reader monad</li>
</ol>
<h2 id="运行实例">运行实例</h2><p>下面提供一个贯穿整个文档的实例,我们会运行这个实例.</p>
<p>比如我们正在为一个火车站创建一个系统.我们的目标是调用方法来准备(装载或组装车辆)并调遣下一辆货车.为了实现这个目标,我们需要创建如下服务类:</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="type">PointSwitcher</span><span class="container">()</span>
<span class="keyword">class</span> <span class="type">TrainCarCoupler</span><span class="container">()</span>
<span class="keyword">class</span> <span class="type">TrainShunter</span><span class="container">(
  <span class="title">pointSwitcher</span>: <span class="type">PointSwitcher</span>,
  <span class="title">trainCarCoupler</span>: <span class="type">TrainCarCoupler</span>)</span>

<span class="keyword">class</span> <span class="type">CraneController</span><span class="container">()</span>
<span class="keyword">class</span> <span class="type">TrainLoader</span><span class="container">(
  <span class="title">craneController</span>: <span class="type">CraneController</span>,
  <span class="title">pointSwitcher</span>: <span class="type">PointSwitcher</span>)</span>

<span class="keyword">class</span> <span class="type">TrainDisptch</span><span class="container">()</span>

<span class="keyword">class</span> <span class="type">TrainStation</span><span class="container">(
  <span class="title">trainShunter</span>: <span class="type">TrainShunter</span>,
  <span class="title">trainLoader</span>: <span class="type">TrainLoader</span>,
  <span class="title">trainDisptch</span>: <span class="type">TrainDisptch</span>)</span>{

  def prepareAndDisptchNextTrain<span class="container">()</span> {...}
}</span>
</code></pre><p>每个类的依赖表示为一个构造器参数.这些依赖构成一个需要进行接线的对象图标.</p>
<h2 id="手动依赖注入">手动依赖注入</h2><p>一种太容易而经常被忽视的方法是手动进行依赖注入.当然这需要更多的编码,但是手动的方式不用顾虑框架必须的一些规定系统参数并且能够更加灵活.</p>
<p>使用DI时,我们需要以某种方法来创建对象图表,也就是为给出的类创建带有合适依赖的实例.当使用框架时这个任务会委托给容器.但是我们也可以通过编写一些简单的代码来完成.</p>
<p>这个对象图表需要尽可能晚的创建,比如在我们应用的主类中创建.如果你之前使用过DI容器,当使用手动DI或和与<code>Macwire</code>一起使用,你会重新发现在应用中有一个主方法的好处.</p>
<p>下面使我们手动DI版本的具体样例:</p>
<pre><code><span class="class"><span class="keyword">object</span> <span class="title">TrainStation</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">App</span>{</span>
  <span class="function"><span class="keyword">val</span> <span class="title">pointSwitcher</span> =</span> <span class="keyword">new</span> <span class="type">PointSwitcher</span>()
  <span class="function"><span class="keyword">val</span> <span class="title">trainCarCoupler</span> =</span> <span class="keyword">new</span> <span class="type">TrainCarCoupler</span>()
  <span class="function"><span class="keyword">val</span> <span class="title">trainShunter</span> =</span> <span class="keyword">new</span> <span class="type">TrainShunter</span>(pointSwitcher, trainCarCoupler)

  <span class="function"><span class="keyword">val</span> <span class="title">canceController</span> =</span> <span class="keyword">new</span> <span class="type">CanceController</span>()
  <span class="function"><span class="keyword">val</span> <span class="title">trainLoader</span> =</span> <span class="keyword">new</span> <span class="type">TrainLoader</span>(craneController, pointSwitcher)

  <span class="function"><span class="keyword">val</span> <span class="title">trainDisptch</span> =</span> <span class="keyword">new</span> <span class="type">TrainDisptch</span>()

  <span class="function"><span class="keyword">val</span> <span class="title">trainStation</span> =</span> <span class="keyword">new</span> <span class="type">TrainStation</span>(trainShunter, trainLoader, trainDisptch)

  trainStation.prepareAndDisptchNextTrain()
}
</code></pre><h2 id="手动DI的建议">手动DI的建议</h2><p>上面方法中的第一个建议是类型安全: 依赖在编译期决定完成,因此可以确定所有的依赖都被集合了.</p>
<p>并不需要运行时反射,虽然它有一些启动时的好处(不需要扫描classpath),但是能够移除很多魔法代码.没有任何注解需要扫描.我们仅仅使用了简单的Scala代码和构造器参数,这能够很好的操纵实例创建的位置.创建对象图表的过程也是清晰的.应用也很易于使用或者打包,比如一个fat-jar.不需要启动容器或者和框架进行斗争.</p>
<p>如果创建一些复杂对象的实例,或者选择一个基于很多配置的实现,感谢手动DI的灵活性,我们可以简单的运行指定代码来计算需要使用的依赖.</p>
<h3 id="val_vs-_lazy_val">val vs. lazy val</h3><p>使用val定义依赖有一个缺点: 当一个依赖在被初始化之前使用了,引用时会是一个<code>null</code>.因为<code>val</code>是从上到下进行计算的.</p>
<p>使用<code>lazy val</code>可以解决这个问题,他可以根据需求进行计算,并且会自动计算正确的初始化顺序.</p>
<p>因此我们的手动DI样例可以修改为:</p>
<pre><code><span class="class"><span class="keyword">object</span> <span class="title">TrainStation</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">App</span> {</span>
   <span class="keyword">lazy</span> <span class="function"><span class="keyword">val</span> <span class="title">pointSwitcher</span> =</span> <span class="keyword">new</span> <span class="type">PointSwitcher</span>()
   <span class="keyword">lazy</span> <span class="function"><span class="keyword">val</span> <span class="title">trainCarCoupler</span> =</span> <span class="keyword">new</span> <span class="type">TrainCarCoupler</span>()
   <span class="keyword">lazy</span> <span class="function"><span class="keyword">val</span> <span class="title">trainShunter</span> =</span> <span class="keyword">new</span> <span class="type">TrainShunter</span>(
      pointSwitcher, trainCarCoupler)

   <span class="keyword">lazy</span> <span class="function"><span class="keyword">val</span> <span class="title">craneController</span> =</span> <span class="keyword">new</span> <span class="type">CraneController</span>()
   <span class="keyword">lazy</span> <span class="function"><span class="keyword">val</span> <span class="title">trainLoader</span> =</span> <span class="keyword">new</span> <span class="type">TrainLoader</span>(
      craneController, pointSwitcher) 

   <span class="keyword">lazy</span> <span class="function"><span class="keyword">val</span> <span class="title">trainDispatch</span> =</span> <span class="keyword">new</span> <span class="type">TrainDispatch</span>() 

   <span class="keyword">lazy</span> <span class="function"><span class="keyword">val</span> <span class="title">trainStation</span> =</span> <span class="keyword">new</span> <span class="type">TrainStation</span>(
      trainShunter, trainLoader, trainDispatch) 

   trainStation.prepareAndDispatchNextTrain() 
}
</code></pre><h3 id="使用MacWire进行架线">使用<code>MacWire</code>进行架线</h3><p>手动DI并不是一个银弹,手动为每个类编写实例穿件代码,并且使用正确的参数,这会很乏味.</p>
<p>这就是<code>MacWire</code>和<code>wire</code>方法能够提供帮助的地方.<code>wire</code>是一个Scala宏命令(<a href="http://scalamacros.org" title="Scala Macros" target="_blank" rel="external">Scala Macros</a>),用于生产实例创建代码.</p>
<p>使用<code>wire</code>修改代码后会变得更简洁:</p>
<pre><code><span class="class"><span class="keyword">object</span> <span class="title">TrainStation</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">App</span> {</span>
   <span class="keyword">lazy</span> <span class="function"><span class="keyword">val</span> <span class="title">pointSwitcher</span> =</span> wire[<span class="type">PointSwitcher</span>]
   <span class="keyword">lazy</span> <span class="function"><span class="keyword">val</span> <span class="title">trainCarCoupler</span> =</span> wire[<span class="type">TrainCarCoupler</span>]
   <span class="keyword">lazy</span> <span class="function"><span class="keyword">val</span> <span class="title">trainShunter</span> =</span> wire[<span class="type">TrainShunter</span>]

   <span class="keyword">lazy</span> <span class="function"><span class="keyword">val</span> <span class="title">craneController</span> =</span> wire[<span class="type">CraneController</span>]
   <span class="keyword">lazy</span> <span class="function"><span class="keyword">val</span> <span class="title">trainLoader</span> =</span> wire[<span class="type">TrainLoader</span>] 
   <span class="keyword">lazy</span> <span class="function"><span class="keyword">val</span> <span class="title">trainDispatch</span> =</span> wire[<span class="type">TrainDispatch</span>]

   <span class="keyword">lazy</span> <span class="function"><span class="keyword">val</span> <span class="title">trainStation</span> =</span> wire[<span class="type">TrainStation</span>]

   trainStation.prepareAndDispatchNextTrain() 
}
</code></pre><p>如果服务添加了一个新的依赖或者参数顺序发生了变化,这些对象图表架线代码并不需要进行改变,宏命令会进行处理.只有在引介一个新的服务时,必须将它加到列表中.</p>
<p>新示例的创建代码由<code>wire</code>在编译时生成,因此当你比较两个例子的字节码时会发现是一致的.生成的代码使用通常的方式进行类型检查,因此我们可以保持手动方式的类型安全.</p>
<p><code>wire</code>宏命令的用法可以手动混合到新实例的创建中.向之前所说的,创建一个复杂实例时会比较有用.</p>
<p>使用<code>wire</code>需要引入<code>com.softwaremill.macwire._</code>,更多整合<code>MacWire</code>的信息可以参阅Github项目Wiki.</p>
<h3 id="wire的工作方式"><code>wire</code>的工作方式</h3><p>提供一个类后,<code>wire</code>宏命令首先尝试查找一个<code>@Inject</code>构造器注解,然后是主(非私有)构造器,最终是半生对象中的<code>apply</code>方法,来确定需要的依赖.对于每个依赖他首先会查找符合参数类型的值,在<code>method/class/object</code>的内部:</p>
<ol>
<li>首先会在当前块中查找一个声明为值的唯一值,被方法包装的参数或者匿名函数</li>
<li>然后会在包含的类型中查找一个被声明或引入的唯一值</li>
<li>然后在父类型(traits/classes)中查找唯一值</li>
<li>如果参数被标记为<code>implicit</code>,它会被<code>Macwire</code>忽略,然后被标准的隐式处理机制处理</li>
</ol>
<p>这里的值可以是<code>val</code>或<code>lazy val</code>,或者返回类型匹配的无参<code>def</code>.</p>
<p>如下情况会引起编译时错误:</p>
<ol>
<li>在<code>block/method/function</code>中声明的类型有多个值,包含父类类型</li>
<li>参数被声明为隐式,但是隐式查找值时失败</li>
<li>没有值符合给出的类型</li>
</ol>
<h3 id="使用隐式参数">使用隐式参数</h3><p>更上面描述类似的一个作用可以通过隐式参数和隐式值获得.如果所有的构造器参数被标记为<code>implicit</code>,并且所有的实例被标记为<code>implicit</code>,同时对象图表已经被连接,Scala编译器会创建一个特有的构造器调用.</p>
<p>首先是类定义:</p>
<pre><code><span class="keyword">class</span> PointSwitcher()
<span class="keyword">class</span> TrainCarCoupler()
<span class="keyword">class</span> TrainShunter(
   <span class="type">implicit</span>
   pointSwitcher: PointSwitcher, 
   trainCarCoupler: TrainCarCoupler)

<span class="keyword">class</span> CraneController()
<span class="keyword">class</span> TrainLoader(
   <span class="type">implicit</span>
   craneController: CraneController, 
   pointSwitcher: PointSwitcher)

<span class="keyword">class</span> TrainDispatch()

<span class="keyword">class</span> TrainStation(
   <span class="type">implicit</span>
   trainShunter: TrainShunter, 
   trainLoader: TrainLoader, 
   trainDispatch: TrainDispatch) {

   def prepareAndDispatchNextTrain() { ... }
}
</code></pre><p>然后进行连线:</p>
<pre><code>object TrainStation <span class="keyword">extends</span> App {
   <span class="type">implicit</span> lazy val pointSwitcher = new PointSwitcher
   <span class="type">implicit</span> lazy val trainCarCoupler = new TrainCarCoupler
   <span class="type">implicit</span> lazy val trainShunter = new TrainShunter

   <span class="type">implicit</span> lazy val craneController = new CraneController
   <span class="type">implicit</span> lazy val trainLoader = new TrainLoader

   <span class="type">implicit</span> lazy val trainDispatch = new TrainDispatch

   <span class="type">implicit</span> lazy val trainStation = new TrainStation

   trainStation.prepareAndDispatchNextTrain()
}
</code></pre><p>然后,使用隐式方式有两个缺点,首先需要标记所有类的构造器参数列表以进行隐式连接.这很不理想,阅读代码的人会疑惑为何要将参数标记为隐式.然后,隐式参数在Scala中的其他地方会用于不同的目的,大量的隐式方式会引起混乱.当然在有些场合是比较合适的.</p>
<h2 id="Simple_scoping">Simple scoping</h2><p>目前为止所有的依赖都被声明为<code>lazy val</code>,他们实质上被标记为单例,在一个单独应用用途的当前作用域中.注意在全局范围内并不是单例,因为我们可以创建多个对象图表的副本.</p>
<p>然而,我们想为每个用途(或称为<code>dependent scope</code>)创建一个依赖的新实例.这时我们可以将该实例声明为一个<code>def</code>而不是<code>lazy val</code>.比如我们每次都需要一个火车分派器的新实例,代码会被修改为:</p>
<pre><code><span class="class"><span class="keyword">object</span> <span class="title">TrainStation</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">App</span> {</span>
   <span class="keyword">lazy</span> <span class="function"><span class="keyword">val</span> <span class="title">pointSwitcher</span> =</span> wire[<span class="type">PointSwitcher</span>]
   <span class="keyword">lazy</span> <span class="function"><span class="keyword">val</span> <span class="title">trainCarCoupler</span> =</span> wire[<span class="type">TrainCarCoupler</span>]
   <span class="keyword">lazy</span> <span class="function"><span class="keyword">val</span> <span class="title">trainShunter</span> =</span> wire[<span class="type">TrainShunter</span>]

   <span class="keyword">lazy</span> <span class="function"><span class="keyword">val</span> <span class="title">craneController</span> =</span> wire[<span class="type">CraneController</span>]
   <span class="keyword">lazy</span> <span class="function"><span class="keyword">val</span> <span class="title">trainLoader</span> =</span> wire[<span class="type">TrainLoader</span>]

   <span class="comment">// note the def instead of lazy val</span>
   <span class="function"><span class="keyword">def</span> <span class="title">trainDispatch</span> =</span> wire[<span class="type">TrainDispatch</span>] 

   <span class="comment">// the stations share all services except the train dispatch,</span>
   <span class="comment">// for which a new instance is create on each usage</span>
   <span class="keyword">lazy</span> <span class="function"><span class="keyword">val</span> <span class="title">trainStationEast</span> =</span> wire[<span class="type">TrainStation</span>]
   <span class="keyword">lazy</span> <span class="function"><span class="keyword">val</span> <span class="title">trainStationWest</span> =</span> wire[<span class="type">TrainStation</span>]

   trainStationEast.prepareAndDispatchNextTrain() 
   trainStationWest.prepareAndDispatchNextTrain() 
} 
</code></pre><p>因此使用Scala构造器我们可以实现两个作用域: 单例或依赖.</p>
<h2 id="模块化对象图表创建">模块化对象图表创建</h2><h3 id="蛋糕模式">蛋糕模式</h3><p>有时在最后时刻创建整个对象图表会不切实际,代码会变得很大且难于阅读.我们需要在一些时候把他们分成小的部分.幸运的是,Scala的<code>trait</code>能够完美的完成整个任务,可以用于拆分对象图表的创建代码.</p>
<p>在每个<code>trait</code>中用于完成各种目的的任务被称为一个<code>module</code>,来创建对象图表的一部分.最后把需要的特质放在一起进行重组.</p>
<p>有多种不同的规则用于将代码拆分到不同的module.一种好的方式是每个<code>package</code>创建一个<code>预连接</code>的module.没个package需要包含一组类,共享或实现一些指定的功能.最可能的就是这些类通过一些方式进行拆分,以便能够进行连线.</p>
<p>传递package的一个额外好处是不仅能够使用代码,同时可以使用一个对象图表片段,这会使代码的使用更加清晰.使用以连线的module并没有一些必须的要求,因此可以通过不同的方式完成.</p>
<p>通常module不能作为单独的形式存在,经常会会依赖于其他module中的类,有两种方式表示依赖.</p>
<h3 id="通过抽象成员表示依赖">通过抽象成员表示依赖</h3><p>由于一些module是一个trait,这允许留下一些未明确的依赖,作为抽象成员.这些抽象成员可以在连线(手动或wire)时使用,但是并不需要提供指定的实现.</p>
<p>当所有的module在应用中组合时,编译器会验证所有这些被定义为抽象成员的实际定义.</p>
<p>注意我们可以声明所有的抽象成员为<code>def</code>,然后在后来可以被实现为<code>val</code>或者<code>lazy val</code>,或者仍然为<code>def</code>,使用<code>def</code>可以保留所有可能的选项.</p>
<p>我们样例代码的连线可以按如下方式拆分,这些类被分组为pakage:</p>
<pre><code><span class="title">package</span> shunting {
<span class="class">   <span class="keyword">class</span> <span class="type">PointSwitcher</span><span class="container">()</span>
   <span class="keyword">class</span> <span class="type">TrainCarCoupler</span><span class="container">()</span>
   <span class="keyword">class</span> <span class="type">TrainShunter</span><span class="container">(
      <span class="title">pointSwitcher</span>: <span class="type">PointSwitcher</span>, 
      <span class="title">trainCarCoupler</span>: <span class="type">TrainCarCoupler</span>)</span>
} 

package loading {
   <span class="keyword">class</span> <span class="type">CraneController</span><span class="container">()</span>
   <span class="keyword">class</span> <span class="type">TrainLoader</span><span class="container">(
      <span class="title">craneController</span>: <span class="type">CraneController</span>, 
      <span class="title">pointSwitcher</span>: <span class="type">PointSwitcher</span>)</span>
}

package station {
   <span class="keyword">class</span> <span class="type">TrainDispatch</span><span class="container">()</span>

   <span class="keyword">class</span> <span class="type">TrainStation</span><span class="container">(
      <span class="title">trainShunter</span>: <span class="type">TrainShunter</span>, 
      <span class="title">trainLoader</span>: <span class="type">TrainLoader</span>, 
      <span class="title">trainDispatch</span>: <span class="type">TrainDispatch</span>)</span> {

      def prepareAndDispatchNextTrain<span class="container">()</span> { ... }
   }
}</span>
</code></pre><p>每个package相当于一个<code>trait-module</code>,注意<code>shunting</code>和<code>loading</code>包之间的依赖表示为一个抽象成员:</p>
<pre><code><span class="keyword">package</span> shunting {
   <span class="class"><span class="keyword">trait</span> <span class="title">ShuntingModule</span> {</span>
      <span class="keyword">lazy</span> <span class="function"><span class="keyword">val</span> <span class="title">pointSwitcher</span> =</span> wire[<span class="type">PointSwitcher</span>]
      <span class="keyword">lazy</span> <span class="function"><span class="keyword">val</span> <span class="title">trainCarCoupler</span> =</span> wire[<span class="type">TrainCarCoupler</span>]
      <span class="keyword">lazy</span> <span class="function"><span class="keyword">val</span> <span class="title">trainShunter</span> =</span> wire[<span class="type">TrainShunter</span>] 
   }
}

<span class="keyword">package</span> loading {
   <span class="class"><span class="keyword">trait</span> <span class="title">LoadingModule</span> {</span>
      <span class="keyword">lazy</span> <span class="function"><span class="keyword">val</span> <span class="title">craneController</span> =</span> wire[<span class="type">CraneController</span>]
      <span class="keyword">lazy</span> <span class="function"><span class="keyword">val</span> <span class="title">trainLoader</span> =</span> wire[<span class="type">TrainLoader</span>] 

      <span class="comment">// dependency of the module</span>
      <span class="function"><span class="keyword">def</span> <span class="title">pointSwitcher</span>:</span> <span class="type">PointSwitcher</span>
   }
}

<span class="keyword">package</span> station {
   <span class="class"><span class="keyword">trait</span> <span class="title">StationModule</span> {</span>
      <span class="keyword">lazy</span> <span class="function"><span class="keyword">val</span> <span class="title">trainDispatch</span> =</span> wire[<span class="type">TrainDispatch</span>]

      <span class="keyword">lazy</span> <span class="function"><span class="keyword">val</span> <span class="title">trainStation</span> =</span> wire[<span class="type">TrainStation</span>]

      <span class="comment">// dependencies of the module</span>
      <span class="function"><span class="keyword">def</span> <span class="title">trainShunter</span>:</span> <span class="type">TrainShunter</span> 
      <span class="function"><span class="keyword">def</span> <span class="title">trainLoader</span>:</span> <span class="type">TrainLoader</span>
   }
}

<span class="class"><span class="keyword">object</span> <span class="title">TrainStation</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">App</span> {</span>
   <span class="function"><span class="keyword">val</span> <span class="title">modules</span> =</span> <span class="keyword">new</span> <span class="type">ShuntingModule</span>
      <span class="keyword">with</span> <span class="type">LoadingModule</span>
      <span class="keyword">with</span> <span class="type">StationModule</span>

   modules.trainStation.prepareAndDispatchNextTrain()   
} 
</code></pre><p>以这样的方式实现依赖需要一个一致的命名约定,比如抽象成员和实现的名字一样.类实例的名字和类的一致然后首字母小写,也是一个很好的命名约定.</p>
<p>这个个方法在一些部分类似于蛋糕模式,因此命名为<code>Thin Cake Pattern</code>.</p>
<h3 id="通过self-types表示依赖">通过<code>self-types</code>表示依赖</h3><p>另一种表示依赖的方式是通过<code>self-types</code>或者扩展其他的<code>trait-modules</code>.这种方式在两个模块之间建立了强烈的连接关系,取代了解耦的抽象成员方式,但是在有些场景也是有应用价值的.</p>
<p>比如,我们可以通过集成一个<code>trait-module</code>来表示<code>shunting,loading,station</code>之间的依赖,而不是使用抽象成员:</p>
<pre><code><span class="keyword">package</span> shunting {
   <span class="class"><span class="keyword">trait</span> <span class="title">ShuntingModule</span> {</span>
      <span class="keyword">lazy</span> <span class="function"><span class="keyword">val</span> <span class="title">pointSwitcher</span> =</span> wire[<span class="type">PointSwitcher</span>]
      <span class="keyword">lazy</span> <span class="function"><span class="keyword">val</span> <span class="title">trainCarCoupler</span> =</span> wire[<span class="type">TrainCarCoupler</span>]
      <span class="keyword">lazy</span> <span class="function"><span class="keyword">val</span> <span class="title">trainShunter</span> =</span> wire[<span class="type">TrainShunter</span>] 
   }
}

<span class="keyword">package</span> loading {
   <span class="class"><span class="keyword">trait</span> <span class="title">LoadingModule</span> {</span>
      <span class="keyword">lazy</span> <span class="function"><span class="keyword">val</span> <span class="title">craneController</span> =</span> wire[<span class="type">CraneController</span>]
      <span class="keyword">lazy</span> <span class="function"><span class="keyword">val</span> <span class="title">trainLoader</span> =</span> wire[<span class="type">TrainLoader</span>] 

      <span class="comment">// dependency expressed using an abstract member</span>
      <span class="function"><span class="keyword">def</span> <span class="title">pointSwitcher</span>:</span> <span class="type">PointSwitcher</span>
   }
}

<span class="keyword">package</span> station {
   <span class="comment">// dependencies expressed using extends</span>
   <span class="class"><span class="keyword">trait</span> <span class="title">StationModule</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">ShuntingModule</span> <span class="keyword"><span class="keyword">with</span></span> <span class="title">LoadingModule</span> {</span>
      <span class="keyword">lazy</span> <span class="function"><span class="keyword">val</span> <span class="title">trainDispatch</span> =</span> wire[<span class="type">TrainDispatch</span>]

      <span class="keyword">lazy</span> <span class="function"><span class="keyword">val</span> <span class="title">trainStation</span> =</span> wire[<span class="type">TrainStation</span>]
   }
}

<span class="class"><span class="keyword">object</span> <span class="title">TrainStation</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">App</span> {</span>
   <span class="function"><span class="keyword">val</span> <span class="title">modules</span> =</span> <span class="keyword">new</span> <span class="type">ShuntingModule</span>
      <span class="keyword">with</span> <span class="type">LoadingModule</span>
      <span class="keyword">with</span> <span class="type">StationModule</span>

   modules.trainStation.prepareAndDispatchNextTrain()   
}
</code></pre><p>使用<code>self-type</code>可以实现一个类似的效果.</p>
<p>这种方式有利于在多个小的模块之外创建一个大型的模块,而不需要重新表示各个小模块之间的依赖.只需要定义一个<code>bigger-module-trait</code>来继承多个<code>smaller-module-traits</code>.</p>
<h3 id="组合模块">组合模块</h3><p>模块可以通过组合的方式结合在一起,可以嵌套多个模块,然后在嵌套的模块内使用依赖来连接(wire)对象.</p>
<p>比如,我们可以给列车管理应用添加一个插件以提供数据收集统计:</p>
<pre><code><span class="keyword">package</span> stats {
   <span class="class"><span class="keyword">class</span> <span class="title">LoadingStats</span>(</span>trainLoader: <span class="type">TrainLoader</span>)
   <span class="class"><span class="keyword">class</span> <span class="title">ShuntingStats</span>(</span>trainShunter: <span class="type">TrainShunter</span>)

   <span class="class"><span class="keyword">class</span> <span class="title">StatsModule</span>(</span>
      shuntingModule: <span class="type">ShuntingModule</span>,
      loadingModule: <span class="type">LoadingModule</span>) {

      <span class="keyword">import</span> shuntingModule._
      <span class="keyword">import</span> loadingModule._

      <span class="keyword">lazy</span> <span class="function"><span class="keyword">val</span> <span class="title">loadingStats</span> =</span> wire[<span class="type">LoadingStats</span>]
      <span class="keyword">lazy</span> <span class="function"><span class="keyword">val</span> <span class="title">shuntingStats</span> =</span> wire[<span class="type">ShuntingStats</span>]    
   }   
}
</code></pre><p>注意<code>import</code>语句,用于将定义在嵌套模块内的依赖引入到当前作用域.</p>
<p>如果给<code>trait/class</code>模块使用实验性质的<code>@Module</code>注解会更加简洁.嵌套模块中带有这个注解的成员会在连线时自动引入.</p>
<pre><code><span class="keyword">package</span> loading {
   <span class="annotation">@Module</span>
   <span class="class"><span class="keyword">trait</span> <span class="title">LoadingModule</span> {</span> ... }
}

<span class="keyword">package</span> shunting {
   <span class="annotation">@Module</span>
   <span class="class"><span class="keyword">trait</span> <span class="title">ShuntingModule</span> {</span> ... }
}

<span class="keyword">package</span> stats {
   <span class="class"><span class="keyword">class</span> <span class="title">LoadingStats</span>(</span>trainLoader: <span class="type">TrainLoader</span>)
   <span class="class"><span class="keyword">class</span> <span class="title">ShuntingStats</span>(</span>trainShunter: <span class="type">TrainShunter</span>)

   <span class="class"><span class="keyword">class</span> <span class="title">StatsModule</span>(</span>
      shuntingModule: <span class="type">ShuntingModule</span>,
      loadingModule: <span class="type">LoadingModule</span>) {

      <span class="keyword">lazy</span> <span class="function"><span class="keyword">val</span> <span class="title">loadingStats</span> =</span> wire[<span class="type">LoadingStats</span>]
      <span class="keyword">lazy</span> <span class="function"><span class="keyword">val</span> <span class="title">shuntingStats</span> =</span> wire[<span class="type">ShuntingStats</span>]    
   }   
}
</code></pre><p>这种方案就不需要再进行<code>import</code>引入了.</p>
<h2 id="多种实现">多种实现</h2><p>一个功能经常会有多种实现,然后我们根据配置进行选择.这种情况可以至少使用两种模式进行模拟.</p>
<p>首先,我们可以有一个单独的模块,包含一个条件逻辑来选择合适的实现.加入火车分流(shunting)有两个选项,传统或者隐形传输,然后是一个配置:</p>
<pre><code><span class="keyword">package</span> shunting {
   <span class="class"><span class="keyword">trait</span> <span class="title">TrainShunter</span>
</span>
   <span class="class"><span class="keyword">class</span> <span class="title">PointSwitcher</span>(</span>)
   <span class="class"><span class="keyword">class</span> <span class="title">TrainCarCoupler</span>(</span>)
   <span class="class"><span class="keyword">class</span> <span class="title">TraditionalTrainShunter</span>(</span>
      pointSwitcher: <span class="type">PointSwitcher</span>,
      trainCarCoupler: <span class="type">TrainCarCoupler</span>) 
      <span class="keyword">extends</span> <span class="type">TrainShunter</span>

   <span class="class"><span class="keyword">class</span> <span class="title">TeleportingTrainShunter</span>(</span>) <span class="keyword">extends</span> <span class="type">TrainShunter</span>

   <span class="class"><span class="keyword">trait</span> <span class="title">ShuntingModule</span> {</span>
      <span class="keyword">lazy</span> <span class="function"><span class="keyword">val</span> <span class="title">pointSwitcher</span> =</span> wire[<span class="type">PointSwitcher</span>]
      <span class="keyword">lazy</span> <span class="function"><span class="keyword">val</span> <span class="title">trainCarCoupler</span> =</span> wire[<span class="type">TrainCarCoupler</span>]

      <span class="keyword">lazy</span> <span class="function"><span class="keyword">val</span> <span class="title">trainShunter</span> =</span> <span class="keyword">if</span> (config.modern) {
         wire[<span class="type">TeleportingTrainShunter</span>]
      } <span class="keyword">else</span> {
         wire[<span class="type">TraditionalTrainShunter</span>]
      }  

      <span class="function"><span class="keyword">def</span> <span class="title">config</span>:</span> <span class="type">Config</span>
   }
}
</code></pre><p>然后,一个模块可以有多个实现.这种场景下,我们可以创建一个仅包含抽象成员的<code>interface-module</code>,这些成员在合适的模块中被实现.这样一个<code>interface-module</code>同时可以很好的用来表示依赖(不用命名约定),并能建立强力的联系:</p>
<pre><code><span class="keyword">package</span> shunting {
   <span class="class"><span class="keyword">trait</span> <span class="title">TrainShunter</span>
</span>
   <span class="class"><span class="keyword">class</span> <span class="title">PointSwitcher</span>(</span>)
   <span class="class"><span class="keyword">class</span> <span class="title">TrainCarCoupler</span>(</span>)
   <span class="class"><span class="keyword">class</span> <span class="title">TraditionalTrainShunter</span>(</span>
      pointSwitcher: <span class="type">PointSwitcher</span>, 
      trainCarCoupler: <span class="type">TrainCarCoupler</span>) 
      <span class="keyword">extends</span> <span class="type">TrainShunter</span>

   <span class="class"><span class="keyword">class</span> <span class="title">TeleportingTrainShunter</span>(</span>) <span class="keyword">extends</span> <span class="type">TrainShunter</span>

   <span class="class"><span class="keyword">trait</span> <span class="title">ShuntingModule</span> {</span>
      <span class="keyword">lazy</span> <span class="function"><span class="keyword">val</span> <span class="title">pointSwitcher</span> =</span> wire[<span class="type">PointSwitcher</span>]

      <span class="function"><span class="keyword">def</span> <span class="title">trainShunter</span>:</span> <span class="type">TrainShunter</span>
   }

   <span class="class"><span class="keyword">trait</span> <span class="title">TraditionalShuntingModule</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">ShuntingModule</span> {</span>
      <span class="keyword">lazy</span> <span class="function"><span class="keyword">val</span> <span class="title">trainCarCoupler</span> =</span> wire[<span class="type">TrainCarCoupler</span>]
      <span class="keyword">lazy</span> <span class="function"><span class="keyword">val</span> <span class="title">trainShunter</span> =</span> wire[<span class="type">TraditionalTrainShunter</span>]
   }

   <span class="class"><span class="keyword">trait</span> <span class="title">ModernShuntingModule</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">ShuntingModule</span> {</span>
      <span class="keyword">lazy</span> <span class="function"><span class="keyword">val</span> <span class="title">trainShunter</span> =</span> wire[<span class="type">TeleportingTrainShunter</span>]
   } 
}  

<span class="comment">// ...</span>

<span class="class"><span class="keyword">object</span> <span class="title">TrainStation</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">App</span> {</span>
   <span class="function"><span class="keyword">val</span> <span class="title">traditionalModules</span> =</span> <span class="keyword">new</span> <span class="type">TraditionalShuntingModule</span>
      <span class="keyword">with</span> <span class="type">LoadingModule</span>
      <span class="keyword">with</span> <span class="type">StationModule</span>

   <span class="function"><span class="keyword">val</span> <span class="title">modernModules</span> =</span> <span class="keyword">new</span> <span class="type">ModernShuntingModule</span>
      <span class="keyword">with</span> <span class="type">LoadingModule</span>
      <span class="keyword">with</span> <span class="type">StationModule</span> 

   traditionalModules.trainStation.prepareAndDispatchNextTrain()   
   modernModules.trainStation.prepareAndDispatchNextTrain()   
} 
</code></pre><p>这个方式缺陷在于模块栈必须在编译时知道,不能动态的选择.</p>
<h2 id="测试">测试</h2><p>每个单独的组件可以通过提供所依赖的<code>mock/stub</code>实现进行测试.而且,使用<code>thin cake pattern</code>时,模块可以进行整合测试(integration-tested),使用定义在模块中的<code>wiring</code>.</p>
<p>当然,我们也需要为那些表示为抽象成员的依赖提供一些实现,可以是<code>mock/stub</code>.同时,能够对一些依赖进行重写来提供一个替代实现以用于测试.这些依赖用于连接模块中定义的图片段.</p>
<p>比如测试分流模块,可以模拟一个与外部系统相互作用的<code>point switcher</code>,然后写一个整合测试:</p>
<pre><code><span class="comment">// main code</span>
<span class="keyword">package</span> shunting {
   <span class="class"><span class="keyword">trait</span> <span class="title">ShuntingModule</span> {</span>
      <span class="keyword">lazy</span> <span class="function"><span class="keyword">val</span> <span class="title">pointSwitcher</span> =</span> wire[<span class="type">PointSwitcher</span>]
      <span class="keyword">lazy</span> <span class="function"><span class="keyword">val</span> <span class="title">trainCarCoupler</span> =</span> wire[<span class="type">TrainCarCoupler</span>]
      <span class="keyword">lazy</span> <span class="function"><span class="keyword">val</span> <span class="title">trainShunter</span> =</span> wire[<span class="type">TrainShunter</span>] 
   }
} 

<span class="comment">// test</span>
<span class="class"><span class="keyword">class</span> <span class="title">ShuntingModuleItTest</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">FlatSpec</span> {</span>
   it should <span class="string">"work"</span> in {
      <span class="comment">// given</span>
      <span class="function"><span class="keyword">val</span> <span class="title">mockPointSwitcher</span> =</span> mock[<span class="type">PointSwitcher</span>]

      <span class="comment">// when</span>
      <span class="function"><span class="keyword">val</span> <span class="title">moduleToTest</span> =</span> <span class="keyword">new</span> <span class="type">ShuntingModule</span> {
         <span class="comment">// the mock implementation will be used to wire the graph</span>
         <span class="keyword">override</span> <span class="keyword">lazy</span> <span class="function"><span class="keyword">val</span> <span class="title">pointSwitcher</span> =</span> mockPointSwitcher
      }
      moduleToTest.trainShunter.shunt()

      <span class="comment">// then</span>
      verify(mockPointSwitcher).switch(...)
   }
}
</code></pre><h2 id="拦截器(Interceptors)">拦截器(Interceptors)</h2><p>拦截器在实现<code>横切关注点(cross-cutting concerns)</code>时非常有用,几乎是所有依赖框架或容器的一部分.然而在Scala中没有拦截器的直接支持,使用一个薄的库层(由MacWire提供),也可以很简单的编写或使用拦截器.</p>
<p>使用拦截器是一个两步的过程.首先需要声明什么需要被拦截.概念上,这不能牵涉任何拦截器的具体实现.然后,需要定义拦截器需要做什么,即行为.</p>
<p>在实现第一部分时我们定义一个抽象拦截器,然后把他应用于已选择的值.比如我们要核查所有的<code>point switches</code>和<code>car couplings</code>事件到外部系统.因此我们要拦截所有作用到<code>PointSwitcher</code>和<code>TrainCarCoupler</code>服务的方法调用:</p>
<pre><code><span class="keyword">package</span> shunting {
   <span class="class"><span class="keyword">trait</span> <span class="title">ShuntingModule</span> {</span>
      <span class="keyword">lazy</span> <span class="function"><span class="keyword">val</span> <span class="title">pointSwitcher</span>:</span> <span class="type">PointSwitcher</span> = 
            logEvents(wire[<span class="type">PointSwitcher</span>])
      <span class="keyword">lazy</span> <span class="function"><span class="keyword">val</span> <span class="title">trainCarCoupler</span>:</span> <span class="type">TrainCarCoupler</span> = 
            logEvents(wire[<span class="type">TrainCarCoupler</span>])
      <span class="keyword">lazy</span> <span class="function"><span class="keyword">val</span> <span class="title">trainShunter</span> =</span> wire[<span class="type">TrainShunter</span>] 

      <span class="function"><span class="keyword">def</span> <span class="title">logEvents</span>:</span> <span class="type">Interceptor</span>
   }
}
</code></pre><p>上面我们已经声明了我们想要把<code>logEvents</code>拦截器作用到<code>pointSwitcher</code>和<code>trainCarCoupler</code>服务.注意到目前还没有提及实现方式.我们仅使用了一个抽象的<code>Interceptor</code>特质,它用于一个<code>apply</code>方法,然后返回通过参数传递给他的相同的类型.</p>
<p>当然我们需要指定一个实现.我们可以尽可能晚的来做这件事,比如在应用的mian实体的最后位置:</p>
<pre><code><span class="class"><span class="keyword">object</span> <span class="title">TrainStation</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">App</span> {</span>
   <span class="function"><span class="keyword">val</span> <span class="title">modules</span> =</span> <span class="keyword">new</span> <span class="type">ShuntingModule</span>
      <span class="keyword">with</span> <span class="type">LoadingModule</span>
      <span class="keyword">with</span> <span class="type">StationModule</span> {

      <span class="keyword">lazy</span> <span class="function"><span class="keyword">val</span> <span class="title">logEvents</span> =</span> <span class="type">ProxyingInterceptor</span> { ctx =&gt;
         println(<span class="string">"Calling method: "</span> + ctx.method.getName())
         ctx.proceed()
      }
   }

   modules.trainStation.prepareAndDispatchNextTrain()   
}
</code></pre><p>这里指定了我们想要创建一个代理拦截器(会创建一个java代理),并提供了响应的行为.注意在处理代理调用时,我们可以使用定义在模块中的所有服务.</p>
<p>在测试时跳过拦截器会比较有利.可以通过提供一个<code>no-op</code>拦截器实现:</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">ShuntingModuleItTest</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">FlatSpec</span> {</span>
   it should <span class="string">"work"</span> in {
      <span class="comment">// given</span>
      <span class="function"><span class="keyword">val</span> <span class="title">moduleToTest</span> =</span> <span class="keyword">new</span> <span class="type">ShuntingModule</span> {
         <span class="keyword">lazy</span> <span class="function"><span class="keyword">val</span> <span class="title">logEvents</span> =</span> <span class="type">NoOpInterceptor</span>
      }

      <span class="comment">// ...</span>
   }
} 
</code></pre><h2 id="Advanced_scoping">Advanced scoping</h2><p>……</p>
<p><a href="http://di-in-scala.github.io" title="DI in Scala: guide" target="_blank" rel="external">DI in Scala: guide</a></p>
</span>
      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Scala/" rel="tag">#Scala</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-prev post-nav-item">
            
          </div>

          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/04/04/Notes-of-Programming-Scala-Metaprogramming-Macros-and-Reflection/" rel="next">Notes of Programming Scala: Metaprogramming - Macros and Reflection</a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

 </div>

        

        
          <div class="comments" id="comments">
            
          </div>
        
      </div>

      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="http://7xiwca.com1.z0.glb.clouddn.com/headpicture.gif" alt="Zhange" itemprop="image"/>
          <p class="site-author-name" itemprop="name">Zhange</p>
        </div>
        <p class="site-description motion-element" itemprop="description">Zhange's notes</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">135</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            
              <span class="site-state-item-count">0</span>
              <span class="site-state-item-name">分类</span>
              
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">40</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      
        <section class="post-toc-wrap sidebar-panel-active">
          <div class="post-toc-indicator-top post-toc-indicator"></div>
          <div class="post-toc">
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#介绍"><span class="nav-number">1.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是依赖注入"><span class="nav-number">2.</span> <span class="nav-text">什么是依赖注入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其他方式"><span class="nav-number">3.</span> <span class="nav-text">其他方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#运行实例"><span class="nav-number">4.</span> <span class="nav-text">运行实例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#手动依赖注入"><span class="nav-number">5.</span> <span class="nav-text">手动依赖注入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#手动DI的建议"><span class="nav-number">6.</span> <span class="nav-text">手动DI的建议</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#val_vs-_lazy_val"><span class="nav-number">6.1.</span> <span class="nav-text">val vs. lazy val</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用MacWire进行架线"><span class="nav-number">6.2.</span> <span class="nav-text">使用MacWire进行架线</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#wire的工作方式"><span class="nav-number">6.3.</span> <span class="nav-text">wire的工作方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用隐式参数"><span class="nav-number">6.4.</span> <span class="nav-text">使用隐式参数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Simple_scoping"><span class="nav-number">7.</span> <span class="nav-text">Simple scoping</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#模块化对象图表创建"><span class="nav-number">8.</span> <span class="nav-text">模块化对象图表创建</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#蛋糕模式"><span class="nav-number">8.1.</span> <span class="nav-text">蛋糕模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通过抽象成员表示依赖"><span class="nav-number">8.2.</span> <span class="nav-text">通过抽象成员表示依赖</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通过self-types表示依赖"><span class="nav-number">8.3.</span> <span class="nav-text">通过self-types表示依赖</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#组合模块"><span class="nav-number">8.4.</span> <span class="nav-text">组合模块</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多种实现"><span class="nav-number">9.</span> <span class="nav-text">多种实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#测试"><span class="nav-number">10.</span> <span class="nav-text">测试</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#拦截器(Interceptors)"><span class="nav-number">11.</span> <span class="nav-text">拦截器(Interceptors)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Advanced_scoping"><span class="nav-number">12.</span> <span class="nav-text">Advanced scoping</span></a></li></ol></div>
            
          </div>
          <div class="post-toc-indicator-bottom post-toc-indicator"></div>
        </section>
      

    </div>
  </aside>


    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner"> <div class="copyright" >
  
  &copy; &nbsp; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="icon-next-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhange</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


 </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  
  
    
    

  


  
  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.1"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.1"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.5.1" id="motion.global"></script>




  <script type="text/javascript" src="/js/nav-toggle.js?v=0.4.5.1"></script>
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  
<script type="text/javascript" src="/js/bootstrap.scrollspy.js?v=0.4.5.1" id="bootstrap.scrollspy.custom"></script>


<script type="text/javascript" id="sidebar.toc.highlight">
  $(document).ready(function () {
    var tocSelector = '.post-toc';
    var $tocSelector = $(tocSelector);
    var activeCurrentSelector = '.active-current';

    $tocSelector
      .on('activate.bs.scrollspy', function () {
        var $currentActiveElement = $(tocSelector + ' .active').last();

        removeCurrentActiveClass();
        $currentActiveElement.addClass('active-current');

        $tocSelector[0].scrollTop = $currentActiveElement.position().top;
      })
      .on('clear.bs.scrollspy', function () {
        removeCurrentActiveClass();
      });

    function removeCurrentActiveClass () {
      $(tocSelector + ' ' + activeCurrentSelector)
        .removeClass(activeCurrentSelector.substring(1));
    }

    function processTOC () {
      getTOCMaxHeight();
      toggleTOCOverflowIndicators();
    }

    function getTOCMaxHeight () {
      var height = $('.sidebar').height() -
                   $tocSelector.position().top -
                   $('.post-toc-indicator-bottom').height();

      $tocSelector.css('height', height);

      return height;
    }

    function toggleTOCOverflowIndicators () {
      tocOverflowIndicator(
        '.post-toc-indicator-top',
        $tocSelector.scrollTop() > 0 ? 'show' : 'hide'
      );

      tocOverflowIndicator(
        '.post-toc-indicator-bottom',
        $tocSelector.scrollTop() >= $tocSelector.find('ol').height() - $tocSelector.height() ? 'hide' : 'show'
      )
    }

    $(document).on('sidebar.motion.complete', function () {
      processTOC();
    });

    $('body').scrollspy({ target: tocSelector });
    $(window).on('resize', function () {
      if ( $('.sidebar').hasClass('sidebar-active') ) {
        processTOC();
      }
    });

    onScroll($tocSelector);

    function onScroll (element) {
      element.on('mousewheel DOMMouseScroll', function (event) {
          var oe = event.originalEvent;
          var delta = oe.wheelDelta || -oe.detail;

          this.scrollTop += ( delta < 0 ? 1 : -1 ) * 30;
          event.preventDefault();

          toggleTOCOverflowIndicators();
      });
    }

    function tocOverflowIndicator (indicator, action) {
      var $indicator = $(indicator);
      var opacity = action === 'show' ? 0.4 : 0;
      $indicator.velocity ?
        $indicator.velocity('stop').velocity({
          opacity: opacity
        }, { duration: 100 }) :
        $indicator.stop().animate({
          opacity: opacity
        }, 100);
    }

  });
</script>

<script type="text/javascript" id="sidebar.nav">
  $(document).ready(function () {
    var html = $('html');
    var TAB_ANIMATE_DURATION = 200;
    var hasVelocity = $.isFunction(html.velocity);

    $('.sidebar-nav li').on('click', function () {
      var item = $(this);
      var activeTabClassName = 'sidebar-nav-active';
      var activePanelClassName = 'sidebar-panel-active';
      if (item.hasClass(activeTabClassName)) {
        return;
      }

      var currentTarget = $('.' + activePanelClassName);
      var target = $('.' + item.data('target'));

      hasVelocity ?
        currentTarget.velocity('transition.slideUpOut', TAB_ANIMATE_DURATION, function () {
          target
            .velocity('stop')
            .velocity('transition.slideDownIn', TAB_ANIMATE_DURATION)
            .addClass(activePanelClassName);
        }) :
        currentTarget.animate({ opacity: 0 }, TAB_ANIMATE_DURATION, function () {
          currentTarget.hide();
          target
            .stop()
            .css({'opacity': 0, 'display': 'block'})
            .animate({ opacity: 1 }, TAB_ANIMATE_DURATION, function () {
              currentTarget.removeClass(activePanelClassName);
              target.addClass(activePanelClassName);
            });
        });

      item.siblings().removeClass(activeTabClassName);
      item.addClass(activeTabClassName);
    });

    $('.post-toc a').on('click', function (e) {
      e.preventDefault();
      var targetSelector = escapeSelector(this.getAttribute('href'));
      var offset = $(targetSelector).offset().top;
      hasVelocity ?
        html.velocity('stop').velocity('scroll', {
          offset: offset  + 'px',
          mobileHA: false
        }) :
        $('html, body').stop().animate({
          scrollTop: offset
        }, 500);
    });

    // Expand sidebar on post detail page by default, when post has a toc.
    var $tocContent = $('.post-toc-content');
    if (isDesktop() && CONFIG.sidebar === 'post') {
      if ($tocContent.length > 0 && $tocContent.html().trim().length > 0) {
        displaySidebar();
      }
    }
  });
</script>



  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
      if (isMobile()) {
        FastClick.attach(document.body);
      }
    });
  </script>

  

  
  

  
  <script type="text/javascript" src="/js/lazyload.js"></script>
  <script type="text/javascript">
    $(function () {
      $("#posts").find('img').lazyload({
        placeholder: "/images/loading.gif",
        effect: "fadeIn"
      });
    });
  </script>
</body>
</html>
